{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/inspector-extension/lib/index.js"],"names":["CommandIDs","open","id","requires","ITranslator","optional","ICommandPalette","ILauncher","ILayoutRestorer","provides","IInspector","autoStart","activate","app","translator","palette","launcher","restorer","trans","load","commands","shell","command","label","__","tracker","WidgetTracker","namespace","inspector","source","addCommand","caption","isEnabled","isDisposed","isAttached","isVisible","icon","args","isLauncher","inspectorIcon","undefined","execute","MainAreaWidget","content","InspectorPanel","title","add","activateById","addItem","category","restore","name","Object","defineProperty","get","set","src","IConsoleTracker","ILabShell","manager","consoles","labShell","handlers","widgetAdded","connect","sender","parent","sessionContext","console","rendermime","connector","KernelConnector","handler","InspectionHandler","cell","promptCell","editor","promptCellCreated","disposed","dispose","currentChanged","_","widget","newValue","has","contextMenu","selector","INotebookTracker","notebooks","activeCell","activeCellChanged"],"mappings":"0KAiBIA,E,yFACJ,SAAWA,GACPA,EAAWC,KAAO,iBADtB,CAEGD,IAAeA,EAAa,KAI/B,MA0KA,EADgB,CAzKE,CACdE,GAAI,4CACJC,SAAU,CAAC,EAAAC,aACXC,SAAU,CAAC,EAAAC,gBAAiB,EAAAC,UAAW,EAAAC,iBACvCC,SAAU,EAAAC,WACVC,WAAW,EACXC,SAAU,CAACC,EAAKC,EAAYC,EAASC,EAAUC,KAC3C,MAAMC,EAAQJ,EAAWK,KAAK,eACxB,SAAEC,EAAQ,MAAEC,GAAUR,EACtBS,EAAUtB,EAAWC,KACrBsB,EAAQL,EAAMM,GAAG,wBAEjBC,EAAU,IAAI,EAAAC,cAAc,CAC9BC,UAFc,cAIlB,IACIC,EADAC,EAAS,KAoDb,OA/BAT,EAASU,WAAWR,EAAS,CACzBS,QAASb,EAAMM,GAAG,2DAClBQ,UAAW,KAAOJ,GACdA,EAAUK,aACTL,EAAUM,aACVN,EAAUO,UACfZ,QACAa,KAAMC,GAASA,EAAKC,WAAa,EAAAC,mBAAgBC,EACjDC,QAAS,KA1BJb,IAAaA,EAAUK,aACxBL,EAAY,IAAI,EAAAc,eAAe,CAC3BC,QAAS,IAAI,EAAAC,eAAe,CAAE9B,iBAElCc,EAAU1B,GAAK,eACf0B,EAAUiB,MAAMtB,MAAQA,EACxBK,EAAUiB,MAAMT,KAAO,EAAAG,cAClBd,EAAQqB,IAAIlB,GACjBC,EAASA,IAAWA,EAAOI,WAAaJ,EAAS,KACjDD,EAAUe,QAAQd,OAASA,GAE1BD,EAAUM,YACXb,EAAMyB,IAAIlB,EAAW,OAAQ,CAAEhB,UAAU,IAE7CS,EAAM0B,aAAanB,EAAU1B,IACtB0B,KAcPb,GACAA,EAAQiC,QAAQ,CAAE1B,UAAS2B,SAAU1B,IAErCP,GACAA,EAAS8B,IAAI,CAAExB,UAASe,KAAM,CAAEC,YAAY,KAG5CrB,GACKA,EAASiC,QAAQzB,EAAS,CAAEH,UAAS6B,KAAM,IAAM,cAG5CC,OAAOC,eAAe,GAAI,SAAU,CAC9CC,IAAK,KAAO1B,GAAaA,EAAUK,WAAa,KAAOL,EAAUe,QAAQd,OACzE0B,IAAMC,IACF3B,EAAS2B,IAAQA,EAAIvB,WAAauB,EAAM,KACpC5B,IAAcA,EAAUK,aACxBL,EAAUe,QAAQd,OAASA,QAU9B,CACb3B,GAAI,2CACJC,SAAU,CAAC,EAAAO,WAAY,EAAA+C,gBAAiB,EAAAC,WACxC/C,WAAW,EACXC,SAAU,CAACC,EAAK8C,EAASC,EAAUC,EAAU/C,KAEzC,MAAMgD,EAAW,GAEjBF,EAASG,YAAYC,SAAQ,CAACC,EAAQC,KAClC,MAAMC,EAAiBD,EAAOE,QAAQD,eAChCE,EAAaH,EAAOE,QAAQC,WAC5BC,EAAY,IAAI,EAAAC,gBAAgB,CAAEJ,mBAClCK,EAAU,IAAI,EAAAC,kBAAkB,CAAEH,YAAWD,eAEnDP,EAASI,EAAOhE,IAAMsE,EAEtB,MAAME,EAAOR,EAAOE,QAAQO,WAC5BH,EAAQI,OAASF,GAAQA,EAAKE,OAE9BV,EAAOE,QAAQS,kBAAkBb,SAAQ,CAACC,EAAQS,KAC9CF,EAAQI,OAASF,GAAQA,EAAKE,UAGlCV,EAAOY,SAASd,SAAQ,YACbF,EAASI,EAAOhE,IACvBsE,EAAQO,gBAIhBlB,EAASmB,eAAehB,SAAQ,CAACiB,EAAG5C,KAChC,MAAM6C,EAAS7C,EAAK8C,SACpB,IAAKD,IAAWtB,EAASwB,IAAIF,GACzB,OAEJ,MAAMrD,EAASiC,EAASoB,EAAOhF,IAC3B2B,IACA8B,EAAQ9B,OAASA,MAGzBhB,EAAIwE,YAAYrC,QAAQ,CACpB1B,QAAStB,EAAWC,KACpBqF,SAAU,iCAOJ,CACdpF,GAAI,4CACJC,SAAU,CAAC,EAAAO,WAAY,EAAA6E,iBAAkB,EAAA7B,WACzC/C,WAAW,EACXC,SAAU,CAACC,EAAK8C,EAAS6B,EAAW3B,KAEhC,MAAMC,EAAW,GAEjB0B,EAAUzB,YAAYC,SAAQ,CAACC,EAAQC,KACnC,MAAMC,EAAiBD,EAAOC,eACxBE,EAAaH,EAAOvB,QAAQ0B,WAC5BC,EAAY,IAAI,EAAAC,gBAAgB,CAAEJ,mBAClCK,EAAU,IAAI,EAAAC,kBAAkB,CAAEH,YAAWD,eAEnDP,EAASI,EAAOhE,IAAMsE,EAEtB,MAAME,EAAOR,EAAOvB,QAAQ8C,WAC5BjB,EAAQI,OAASF,GAAQA,EAAKE,OAE9BV,EAAOvB,QAAQ+C,kBAAkB1B,SAAQ,CAACC,EAAQS,KAC9CF,EAAQI,OAASF,GAAQA,EAAKE,UAGlCV,EAAOY,SAASd,SAAQ,YACbF,EAASI,EAAOhE,IACvBsE,EAAQO,gBAIhBlB,EAASmB,eAAehB,SAAQ,CAACC,EAAQ5B,KACrC,MAAM6C,EAAS7C,EAAK8C,SACpB,IAAKD,IAAWM,EAAUJ,IAAIF,GAC1B,OAEJ,MAAMrD,EAASiC,EAASoB,EAAOhF,IAC3B2B,IACA8B,EAAQ9B,OAASA,MAGzBhB,EAAIwE,YAAYrC,QAAQ,CACpB1B,QAAStB,EAAWC,KACpBqF,SAAU","file":"3139.e20c3d8ead5d40ebc6d1.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module inspector-extension\n */\nimport { ILabShell, ILayoutRestorer } from '@jupyterlab/application';\nimport { ICommandPalette, MainAreaWidget, WidgetTracker } from '@jupyterlab/apputils';\nimport { IConsoleTracker } from '@jupyterlab/console';\nimport { IInspector, InspectionHandler, InspectorPanel, KernelConnector } from '@jupyterlab/inspector';\nimport { ILauncher } from '@jupyterlab/launcher';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { inspectorIcon } from '@jupyterlab/ui-components';\n/**\n * The command IDs used by the inspector plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.open = 'inspector:open';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * A service providing code introspection.\n */\nconst inspector = {\n    id: '@jupyterlab/inspector-extension:inspector',\n    requires: [ITranslator],\n    optional: [ICommandPalette, ILauncher, ILayoutRestorer],\n    provides: IInspector,\n    autoStart: true,\n    activate: (app, translator, palette, launcher, restorer) => {\n        const trans = translator.load('jupyterlab');\n        const { commands, shell } = app;\n        const command = CommandIDs.open;\n        const label = trans.__('Show Contextual Help');\n        const namespace = 'inspector';\n        const tracker = new WidgetTracker({\n            namespace\n        });\n        let source = null;\n        let inspector;\n        function openInspector() {\n            if (!inspector || inspector.isDisposed) {\n                inspector = new MainAreaWidget({\n                    content: new InspectorPanel({ translator })\n                });\n                inspector.id = 'jp-inspector';\n                inspector.title.label = label;\n                inspector.title.icon = inspectorIcon;\n                void tracker.add(inspector);\n                source = source && !source.isDisposed ? source : null;\n                inspector.content.source = source;\n            }\n            if (!inspector.isAttached) {\n                shell.add(inspector, 'main', { activate: false });\n            }\n            shell.activateById(inspector.id);\n            return inspector;\n        }\n        // Add command to registry.\n        commands.addCommand(command, {\n            caption: trans.__('Live updating code documentation from the active kernel'),\n            isEnabled: () => !inspector ||\n                inspector.isDisposed ||\n                !inspector.isAttached ||\n                !inspector.isVisible,\n            label,\n            icon: args => (args.isLauncher ? inspectorIcon : undefined),\n            execute: () => openInspector()\n        });\n        // Add command to UI where possible.\n        if (palette) {\n            palette.addItem({ command, category: label });\n        }\n        if (launcher) {\n            launcher.add({ command, args: { isLauncher: true } });\n        }\n        // Handle state restoration.\n        if (restorer) {\n            void restorer.restore(tracker, { command, name: () => 'inspector' });\n        }\n        // Create a proxy to pass the `source` to the current inspector.\n        const proxy = Object.defineProperty({}, 'source', {\n            get: () => !inspector || inspector.isDisposed ? null : inspector.content.source,\n            set: (src) => {\n                source = src && !src.isDisposed ? src : null;\n                if (inspector && !inspector.isDisposed) {\n                    inspector.content.source = source;\n                }\n            }\n        });\n        return proxy;\n    }\n};\n/**\n * An extension that registers consoles for inspection.\n */\nconst consoles = {\n    id: '@jupyterlab/inspector-extension:consoles',\n    requires: [IInspector, IConsoleTracker, ILabShell],\n    autoStart: true,\n    activate: (app, manager, consoles, labShell, translator) => {\n        // Maintain association of new consoles with their respective handlers.\n        const handlers = {};\n        // Create a handler for each console that is created.\n        consoles.widgetAdded.connect((sender, parent) => {\n            const sessionContext = parent.console.sessionContext;\n            const rendermime = parent.console.rendermime;\n            const connector = new KernelConnector({ sessionContext });\n            const handler = new InspectionHandler({ connector, rendermime });\n            // Associate the handler to the widget.\n            handlers[parent.id] = handler;\n            // Set the initial editor.\n            const cell = parent.console.promptCell;\n            handler.editor = cell && cell.editor;\n            // Listen for prompt creation.\n            parent.console.promptCellCreated.connect((sender, cell) => {\n                handler.editor = cell && cell.editor;\n            });\n            // Listen for parent disposal.\n            parent.disposed.connect(() => {\n                delete handlers[parent.id];\n                handler.dispose();\n            });\n        });\n        // Keep track of console instances and set inspector source.\n        labShell.currentChanged.connect((_, args) => {\n            const widget = args.newValue;\n            if (!widget || !consoles.has(widget)) {\n                return;\n            }\n            const source = handlers[widget.id];\n            if (source) {\n                manager.source = source;\n            }\n        });\n        app.contextMenu.addItem({\n            command: CommandIDs.open,\n            selector: '.jp-CodeConsole-promptCell'\n        });\n    }\n};\n/**\n * An extension that registers notebooks for inspection.\n */\nconst notebooks = {\n    id: '@jupyterlab/inspector-extension:notebooks',\n    requires: [IInspector, INotebookTracker, ILabShell],\n    autoStart: true,\n    activate: (app, manager, notebooks, labShell) => {\n        // Maintain association of new notebooks with their respective handlers.\n        const handlers = {};\n        // Create a handler for each notebook that is created.\n        notebooks.widgetAdded.connect((sender, parent) => {\n            const sessionContext = parent.sessionContext;\n            const rendermime = parent.content.rendermime;\n            const connector = new KernelConnector({ sessionContext });\n            const handler = new InspectionHandler({ connector, rendermime });\n            // Associate the handler to the widget.\n            handlers[parent.id] = handler;\n            // Set the initial editor.\n            const cell = parent.content.activeCell;\n            handler.editor = cell && cell.editor;\n            // Listen for active cell changes.\n            parent.content.activeCellChanged.connect((sender, cell) => {\n                handler.editor = cell && cell.editor;\n            });\n            // Listen for parent disposal.\n            parent.disposed.connect(() => {\n                delete handlers[parent.id];\n                handler.dispose();\n            });\n        });\n        // Keep track of notebook instances and set inspector source.\n        labShell.currentChanged.connect((sender, args) => {\n            const widget = args.newValue;\n            if (!widget || !notebooks.has(widget)) {\n                return;\n            }\n            const source = handlers[widget.id];\n            if (source) {\n                manager.source = source;\n            }\n        });\n        app.contextMenu.addItem({\n            command: CommandIDs.open,\n            selector: '.jp-Notebook'\n        });\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [inspector, consoles, notebooks];\nexport default plugins;\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}