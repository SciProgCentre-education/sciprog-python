{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/searchoverlay.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/searchinstance.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/searchproviderregistry.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/providers/genericsearchprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/providers/codemirrorsearchprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/providers/notebooksearchprovider.js"],"names":["OVERLAY_ROW_CLASS","INPUT_BUTTON_CLASS_OFF","INPUT_BUTTON_CLASS_ON","UP_DOWN_BUTTON_CLASS","SEARCH_OPTIONS_DISABLED_CLASS","REPLACE_BUTTON_CLASS","REPLACE_BUTTON_WRAPPER_CLASS","BUTTON_CONTENT_CLASS","BUTTON_WRAPPER_CLASS","SearchEntry","props","super","this","translator","nullTranslator","_trans","load","searchInputRef","_a","current","select","forceFocus","focusInput","caseButtonToggleClass","classes","caseSensitive","regexButtonToggleClass","useRegex","wrapperClass","inputFocused","className","placeholder","searchText","undefined","__","value","onChange","e","onKeyDown","onKeydown","tabIndex","onFocus","onInputFocus","onBlur","onInputBlur","ref","onClick","onCaseSensitiveToggled","caseSensitiveIcon","tag","onRegexToggled","regexIcon","ReplaceEntry","replaceInputRef","replaceText","onReplaceKeydown","onReplaceCurrent","onReplaceAll","UpDownButtons","onHighlightPrevious","caretUpEmptyThinIcon","onHightlightNext","caretDownEmptyThinIcon","SearchIndices","totalMatches","currentIndex","FilterToggle","enabled","toggleEnabled","ellipsesIcon","height","width","FilterSelection","canToggleOutput","trans","type","disabled","checked","searchOutput","toggleOutput","canToggleSelectedCells","searchSelectedCells","toggleSelectedCells","SearchOverlay","_debouncedStartSearch","Debouncer","_executeSearch","state","overlayState","replaceEntryRef","_toggleSearchOutput","bind","_toggleSearchSelectedCells","event","target","setState","invoke","keyCode","preventDefault","stopPropagation","shiftKey","_onClose","goForward","filterChanged","query","input","Private","parseQuery","errorMessage","message","regexEqual","onStartQuery","filters","onEndSearch","dispose","replaceEntryShown","searchInputFocused","prevState","Object","assign","output","selectedCells","filtersOpen","showReplace","isReadOnly","showFilter","hasOutputs","filterToggle","_toggleFiltersOpen","filter","key","icon","caretDownIcon","caretRightIcon","_onReplaceToggled","react","elementPosition","_onSearchKeydown","_onSearchChange","_onSearchInputFocus","_onSearchInputBlur","closeIcon","_onReplaceKeydown","_onReplaceChange","hidden","length","queryString","regex","flag","queryText","replace","ret","RegExp","test","a","b","source","global","ignoreCase","multiline","SearchInstance","widget","searchProvider","_displayState","replaceInputFocused","_displayUpdateSignal","Signal","_isDisposed","_disposed","_widget","_activeProvider","initialQuery","getInitialQuery","_searchWidget","options","widgetChanged","ReactWidget","UseSignal","signal","initialArgs","_","args","addClass","createSearchOverlay","_onCaseSensitiveToggled","_onRegexToggled","_highlightNext","_highlightPrevious","_startQuery","_replaceCurrent","_replaceAll","disposed","connect","activate","MainAreaWidget","node","style","top","toolbar","clientHeight","NotebookPanel","content","activeCellChanged","_displaySearchWidget","emit","matches","currentMatchIndex","_updateDisplay","endQuery","startQuery","updateIndices","changed","newText","replaceCurrentMatch","replaceAllMatches","isDisposed","endSearch","isAttached","Widget","highlightNext","highlightPrevious","SearchProviderRegistry","_changed","_providerMap","Map","provider","set","DisposableDelegate","delete","_findMatchingProvider","providerMap","P","values","canSearchOn","ISearchProviderRegistry","Token","FOUND_CLASSES","SELECTED_CLASSES","GenericSearchProvider","isSubProvider","_matches","_mutationObserver","MutationObserver","_onWidgetChanged","searchTarget","that","_query","disconnect","walker","document","createTreeWalker","NodeFilter","SHOW_TEXT","acceptNode","parentElement","nodeName","UNSUPPORTED_ELEMENTS","FILTER_REJECT","textContent","FILTER_ACCEPT","nodes","originalNodes","nextNode","push","cloneNode","flags","indexOf","forEach","nodeIndex","q","subsections","match","exec","start","index","end","text","originalNode","originalLength","lastNodeAdded","newMatches","idx","spannedNode","createElement","classList","add","slice","nodeType","Node","TEXT_NODE","endText","splitText","parentNode","insertBefore","prepend","append","unshift","fragment","line","column","matchesIndex","indexInOriginal","spanElement","_currentMatch","observe","attributes","characterData","childList","subtree","removeOverlay","replaceWith","reverse","remove","nextIndex","el","boundingClientRect","getBoundingClientRect","bottom","window","innerHeight","documentElement","left","right","innerWidth","clientWidth","elementInViewport","scrollIntoView","focus","Promise","resolve","domain","map","m","mutations","observer","BASE","HEAD","LINK","META","STYLE","TITLE","BODY","AREA","AUDIO","IMG","MAP","TRACK","VIDEO","APPLET","EMBED","IFRAME","NOEMBED","OBJECT","PARAM","PICTURE","SOURCE","CANVAS","NOSCRIPT","SCRIPT","SVG","CodeMirrorSearchProvider","_matchState","selection","editor","doc","getSelection","search","Error","_cm","_refreshOverlay","refreshOverlay","_onDocChanged","_setInitialMatches","_parseMatchesFromState","cursorMatch","_findNext","from","ch","_overlay","getCursor","to","setSelection","_toEditorPos","replaceOccurred","_currentMatchIsSelected","cursor","getSearchCursor","findNext","operation","FileEditor","CodeMirrorEditor","changeObj","_b","removed","_getSearchOverlay","addOverlay","firstLine","lastLine","getRange","split","lineNumber","lastIndex","col","matchObj","token","stream","currentPos","pos","lineText","string","lineOracle","matchLength","substr","eol","skipToEnd","cursorToGet","lastPosition","position","find","setCursorPosition","scroll","startOrEnd","fromPos","toPos","selRange","keys","reduce","result","lineKey","parseInt","lineMatches","posKey","posIn","currentSelection","currentSelectionLength","selectionIsOneLine","SearchState","NotebookSearchProvider","_searchProviders","_unRenderedMarkdownCells","_cellsWithMatches","activeCell","_searchTarget","cells","widgets","_filters","entries","cell","isSelectedOrActive","hide","indexTotal","allMatches","cmEditor","cmSearchProvider","cellShouldReRender","MarkdownCell","rendered","inputHidden","matchesFromCell","startQueryCodeMirror","_onSearchProviderChanged","concat","CodeCell","outputProivder","matchesFromOutput","outputArea","show","_stepNext","_updatedCurrentProvider","_refreshCurrentCellEditor","_refreshCellsEditorsInBackground","n","i","refreshNextNCells","stop","refresh","setTimeout","queriesEnded","model","_currentProvider","all","activeCellIndex","searchEnded","mode","currentMatch","_getMatchesFromCells","currentProviderIndex","ArrayExt","nextProviderIndex","currentSearchPair","steps","providerIndex","numProviders","nextSearchPair","newPosCM","newPos","notebook","cellMatches","cm"],"mappings":"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","file":"131.0e641fc0e1ae0d14aa10.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ReactWidget, UseSignal } from '@jupyterlab/apputils';\nimport { caretDownIcon, caretDownEmptyThinIcon, caretRightIcon, caretUpEmptyThinIcon, caseSensitiveIcon, classes, closeIcon, ellipsesIcon, regexIcon } from '@jupyterlab/ui-components';\nimport { Debouncer } from '@lumino/polling';\nimport * as React from 'react';\nimport { nullTranslator } from '@jupyterlab/translation';\nconst OVERLAY_CLASS = 'jp-DocumentSearch-overlay';\nconst OVERLAY_ROW_CLASS = 'jp-DocumentSearch-overlay-row';\nconst INPUT_CLASS = 'jp-DocumentSearch-input';\nconst INPUT_WRAPPER_CLASS = 'jp-DocumentSearch-input-wrapper';\nconst INPUT_BUTTON_CLASS_OFF = 'jp-DocumentSearch-input-button-off';\nconst INPUT_BUTTON_CLASS_ON = 'jp-DocumentSearch-input-button-on';\nconst INDEX_COUNTER_CLASS = 'jp-DocumentSearch-index-counter';\nconst UP_DOWN_BUTTON_WRAPPER_CLASS = 'jp-DocumentSearch-up-down-wrapper';\nconst UP_DOWN_BUTTON_CLASS = 'jp-DocumentSearch-up-down-button';\nconst ELLIPSES_BUTTON_CLASS = 'jp-DocumentSearch-ellipses-button';\nconst ELLIPSES_BUTTON_ENABLED_CLASS = 'jp-DocumentSearch-ellipses-button-enabled';\nconst REGEX_ERROR_CLASS = 'jp-DocumentSearch-regex-error';\nconst SEARCH_OPTIONS_CLASS = 'jp-DocumentSearch-search-options';\nconst SEARCH_OPTIONS_DISABLED_CLASS = 'jp-DocumentSearch-search-options-disabled';\nconst REPLACE_ENTRY_CLASS = 'jp-DocumentSearch-replace-entry';\nconst REPLACE_BUTTON_CLASS = 'jp-DocumentSearch-replace-button';\nconst REPLACE_BUTTON_WRAPPER_CLASS = 'jp-DocumentSearch-replace-button-wrapper';\nconst REPLACE_WRAPPER_CLASS = 'jp-DocumentSearch-replace-wrapper-class';\nconst REPLACE_TOGGLE_CLASS = 'jp-DocumentSearch-replace-toggle';\nconst FOCUSED_INPUT = 'jp-DocumentSearch-focused-input';\nconst TOGGLE_WRAPPER = 'jp-DocumentSearch-toggle-wrapper';\nconst TOGGLE_PLACEHOLDER = 'jp-DocumentSearch-toggle-placeholder';\nconst BUTTON_CONTENT_CLASS = 'jp-DocumentSearch-button-content';\nconst BUTTON_WRAPPER_CLASS = 'jp-DocumentSearch-button-wrapper';\nconst SPACER_CLASS = 'jp-DocumentSearch-spacer';\nclass SearchEntry extends React.Component {\n    constructor(props) {\n        super(props);\n        this.translator = props.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        this.searchInputRef = React.createRef();\n    }\n    /**\n     * Focus the input.\n     */\n    focusInput() {\n        var _a;\n        // Select (and focus) any text already present.\n        // This makes typing in the box starts a new query (the common case),\n        // while arrow keys can be used to move cursor in preparation for\n        // modifying previous query.\n        (_a = this.searchInputRef.current) === null || _a === void 0 ? void 0 : _a.select();\n    }\n    componentDidUpdate() {\n        if (this.props.forceFocus) {\n            this.focusInput();\n        }\n    }\n    render() {\n        const caseButtonToggleClass = classes(this.props.caseSensitive ? INPUT_BUTTON_CLASS_ON : INPUT_BUTTON_CLASS_OFF, BUTTON_CONTENT_CLASS);\n        const regexButtonToggleClass = classes(this.props.useRegex ? INPUT_BUTTON_CLASS_ON : INPUT_BUTTON_CLASS_OFF, BUTTON_CONTENT_CLASS);\n        const wrapperClass = `${INPUT_WRAPPER_CLASS} ${this.props.inputFocused ? FOCUSED_INPUT : ''}`;\n        return (React.createElement(\"div\", { className: wrapperClass },\n            React.createElement(\"input\", { placeholder: this.props.searchText ? undefined : this._trans.__('Find'), className: INPUT_CLASS, value: this.props.searchText, onChange: e => this.props.onChange(e), onKeyDown: e => this.props.onKeydown(e), tabIndex: 0, onFocus: e => this.props.onInputFocus(), onBlur: e => this.props.onInputBlur(), ref: this.searchInputRef }),\n            React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => this.props.onCaseSensitiveToggled(), tabIndex: 0 },\n                React.createElement(caseSensitiveIcon.react, { className: caseButtonToggleClass, tag: \"span\" })),\n            React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => this.props.onRegexToggled(), tabIndex: 0 },\n                React.createElement(regexIcon.react, { className: regexButtonToggleClass, tag: \"span\" }))));\n    }\n}\nclass ReplaceEntry extends React.Component {\n    constructor(props) {\n        super(props);\n        this._trans = (props.translator || nullTranslator).load('jupyterlab');\n        this.replaceInputRef = React.createRef();\n    }\n    render() {\n        return (React.createElement(\"div\", { className: REPLACE_WRAPPER_CLASS },\n            React.createElement(\"input\", { placeholder: this.props.replaceText ? undefined : this._trans.__('Replace'), className: REPLACE_ENTRY_CLASS, value: this.props.replaceText, onKeyDown: e => this.props.onReplaceKeydown(e), onChange: e => this.props.onChange(e), tabIndex: 0, ref: this.replaceInputRef }),\n            React.createElement(\"button\", { className: REPLACE_BUTTON_WRAPPER_CLASS, onClick: () => this.props.onReplaceCurrent(), tabIndex: 0 },\n                React.createElement(\"span\", { className: `${REPLACE_BUTTON_CLASS} ${BUTTON_CONTENT_CLASS}`, tabIndex: 0 }, this._trans.__('Replace'))),\n            React.createElement(\"button\", { className: REPLACE_BUTTON_WRAPPER_CLASS, tabIndex: 0, onClick: () => this.props.onReplaceAll() },\n                React.createElement(\"span\", { className: `${REPLACE_BUTTON_CLASS} ${BUTTON_CONTENT_CLASS}`, tabIndex: -1 }, this._trans.__('Replace All')))));\n    }\n}\nfunction UpDownButtons(props) {\n    return (React.createElement(\"div\", { className: UP_DOWN_BUTTON_WRAPPER_CLASS },\n        React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => props.onHighlightPrevious(), tabIndex: 0 },\n            React.createElement(caretUpEmptyThinIcon.react, { className: classes(UP_DOWN_BUTTON_CLASS, BUTTON_CONTENT_CLASS), tag: \"span\" })),\n        React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => props.onHightlightNext(), tabIndex: 0 },\n            React.createElement(caretDownEmptyThinIcon.react, { className: classes(UP_DOWN_BUTTON_CLASS, BUTTON_CONTENT_CLASS), tag: \"span\" }))));\n}\nfunction SearchIndices(props) {\n    return (React.createElement(\"div\", { className: INDEX_COUNTER_CLASS }, props.totalMatches === 0\n        ? '-/-'\n        : `${props.currentIndex === null ? '-' : props.currentIndex + 1}/${props.totalMatches}`));\n}\nclass FilterToggle extends React.Component {\n    render() {\n        let className = `${ELLIPSES_BUTTON_CLASS} ${BUTTON_CONTENT_CLASS}`;\n        if (this.props.enabled) {\n            className = `${className} ${ELLIPSES_BUTTON_ENABLED_CLASS}`;\n        }\n        return (React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => this.props.toggleEnabled(), tabIndex: 0 },\n            React.createElement(ellipsesIcon.react, { className: className, tag: \"span\", height: \"20px\", width: \"20px\" })));\n    }\n}\nclass FilterSelection extends React.Component {\n    render() {\n        return (React.createElement(\"label\", { className: SEARCH_OPTIONS_CLASS },\n            React.createElement(\"div\", null,\n                React.createElement(\"span\", { className: this.props.canToggleOutput ? '' : SEARCH_OPTIONS_DISABLED_CLASS }, this.props.trans.__('Search Cell Outputs')),\n                React.createElement(\"input\", { type: \"checkbox\", disabled: !this.props.canToggleOutput, checked: this.props.searchOutput, onChange: this.props.toggleOutput })),\n            React.createElement(\"div\", null,\n                React.createElement(\"span\", { className: this.props.canToggleSelectedCells\n                        ? ''\n                        : SEARCH_OPTIONS_DISABLED_CLASS }, this.props.trans.__('Search Selected Cell(s)')),\n                React.createElement(\"input\", { type: \"checkbox\", disabled: !this.props.canToggleSelectedCells, checked: this.props.searchSelectedCells, onChange: this.props.toggleSelectedCells }))));\n    }\n}\nclass SearchOverlay extends React.Component {\n    constructor(props) {\n        super(props);\n        this._debouncedStartSearch = new Debouncer(() => {\n            this._executeSearch(true, this.state.searchText);\n        }, 500);\n        this.translator = props.translator || nullTranslator;\n        this.state = props.overlayState;\n        this.replaceEntryRef = React.createRef();\n        this._toggleSearchOutput = this._toggleSearchOutput.bind(this);\n        this._toggleSearchSelectedCells = this._toggleSearchSelectedCells.bind(this);\n    }\n    componentDidMount() {\n        if (this.state.searchText) {\n            this._executeSearch(true, this.state.searchText);\n        }\n    }\n    _onSearchChange(event) {\n        const searchText = event.target.value;\n        this.setState({ searchText: searchText });\n        void this._debouncedStartSearch.invoke();\n    }\n    _onReplaceChange(event) {\n        this.setState({ replaceText: event.target.value });\n    }\n    _onSearchKeydown(event) {\n        if (event.keyCode === 13) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._executeSearch(!event.shiftKey);\n        }\n        else if (event.keyCode === 27) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._onClose();\n        }\n    }\n    _onReplaceKeydown(event) {\n        if (event.keyCode === 13) {\n            event.preventDefault();\n            event.stopPropagation();\n            this.props.onReplaceCurrent(this.state.replaceText);\n        }\n    }\n    _executeSearch(goForward, searchText, filterChanged = false) {\n        // execute search!\n        let query;\n        const input = searchText ? searchText : this.state.searchText;\n        try {\n            query = Private.parseQuery(input, this.props.overlayState.caseSensitive, this.props.overlayState.useRegex);\n            this.setState({ errorMessage: '' });\n        }\n        catch (e) {\n            this.setState({ errorMessage: e.message });\n            return;\n        }\n        if (Private.regexEqual(this.props.overlayState.query, query) &&\n            !filterChanged) {\n            if (goForward) {\n                this.props.onHightlightNext();\n            }\n            else {\n                this.props.onHighlightPrevious();\n            }\n            return;\n        }\n        this.props.onStartQuery(query, this.state.filters);\n    }\n    _onClose() {\n        // Clean up and close widget.\n        this.props.onEndSearch();\n        this._debouncedStartSearch.dispose();\n    }\n    _onReplaceToggled() {\n        this.setState({\n            replaceEntryShown: !this.state.replaceEntryShown\n        });\n    }\n    _onSearchInputFocus() {\n        if (!this.state.searchInputFocused) {\n            this.setState({ searchInputFocused: true });\n        }\n    }\n    _onSearchInputBlur() {\n        if (this.state.searchInputFocused) {\n            this.setState({ searchInputFocused: false });\n        }\n    }\n    _toggleSearchOutput() {\n        this.setState(prevState => (Object.assign(Object.assign({}, prevState), { filters: Object.assign(Object.assign({}, prevState.filters), { output: !prevState.filters.output }) })), () => this._executeSearch(true, undefined, true));\n    }\n    _toggleSearchSelectedCells() {\n        this.setState(prevState => (Object.assign(Object.assign({}, prevState), { filters: Object.assign(Object.assign({}, prevState.filters), { selectedCells: !prevState.filters.selectedCells }) })), () => this._executeSearch(true, undefined, true));\n    }\n    _toggleFiltersOpen() {\n        this.setState(prevState => ({\n            filtersOpen: !prevState.filtersOpen\n        }));\n    }\n    render() {\n        const showReplace = !this.props.isReadOnly && this.state.replaceEntryShown;\n        const showFilter = this.props.hasOutputs;\n        const filterToggle = showFilter ? (React.createElement(FilterToggle, { enabled: this.state.filtersOpen, toggleEnabled: () => this._toggleFiltersOpen() })) : null;\n        const filter = showFilter ? (React.createElement(FilterSelection, { key: 'filter', canToggleOutput: !showReplace, canToggleSelectedCells: true, searchOutput: this.state.filters.output, searchSelectedCells: this.state.filters.selectedCells, toggleOutput: this._toggleSearchOutput, toggleSelectedCells: this._toggleSearchSelectedCells, trans: this.translator.load('jupyterlab') })) : null;\n        const icon = this.state.replaceEntryShown ? caretDownIcon : caretRightIcon;\n        // TODO: Error messages from regex are not currently localizable.\n        return [\n            React.createElement(\"div\", { className: OVERLAY_ROW_CLASS, key: 0 },\n                this.props.isReadOnly ? (React.createElement(\"div\", { className: TOGGLE_PLACEHOLDER })) : (React.createElement(\"button\", { className: TOGGLE_WRAPPER, onClick: () => this._onReplaceToggled(), tabIndex: 0 },\n                    React.createElement(icon.react, { className: `${REPLACE_TOGGLE_CLASS} ${BUTTON_CONTENT_CLASS}`, tag: \"span\", elementPosition: \"center\", height: \"20px\", width: \"20px\" }))),\n                React.createElement(SearchEntry, { useRegex: this.props.overlayState.useRegex, caseSensitive: this.props.overlayState.caseSensitive, onCaseSensitiveToggled: () => {\n                        this.props.onCaseSensitiveToggled();\n                        this._executeSearch(true);\n                    }, onRegexToggled: () => {\n                        this.props.onRegexToggled();\n                        this._executeSearch(true);\n                    }, onKeydown: (e) => this._onSearchKeydown(e), onChange: (e) => this._onSearchChange(e), onInputFocus: this._onSearchInputFocus.bind(this), onInputBlur: this._onSearchInputBlur.bind(this), inputFocused: this.state.searchInputFocused, searchText: this.state.searchText, forceFocus: this.props.overlayState.forceFocus, translator: this.translator }),\n                React.createElement(SearchIndices, { currentIndex: this.props.overlayState.currentIndex, totalMatches: this.props.overlayState.totalMatches }),\n                React.createElement(UpDownButtons, { onHighlightPrevious: () => this._executeSearch(false), onHightlightNext: () => this._executeSearch(true) }),\n                showReplace ? null : filterToggle,\n                React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => this._onClose(), tabIndex: 0 },\n                    React.createElement(closeIcon.react, { className: \"jp-icon-hover\", elementPosition: \"center\", height: \"16px\", width: \"16px\" }))),\n            React.createElement(\"div\", { className: OVERLAY_ROW_CLASS, key: 1 }, showReplace ? (React.createElement(React.Fragment, null,\n                React.createElement(ReplaceEntry, { onReplaceKeydown: (e) => this._onReplaceKeydown(e), onChange: (e) => this._onReplaceChange(e), onReplaceCurrent: () => this.props.onReplaceCurrent(this.state.replaceText), onReplaceAll: () => this.props.onReplaceAll(this.state.replaceText), replaceText: this.state.replaceText, ref: this.replaceEntryRef, translator: this.translator }),\n                React.createElement(\"div\", { className: SPACER_CLASS }),\n                filterToggle)) : null),\n            this.state.filtersOpen ? filter : null,\n            React.createElement(\"div\", { className: REGEX_ERROR_CLASS, hidden: !!this.state.errorMessage && this.state.errorMessage.length === 0, key: 3 }, this.state.errorMessage)\n        ];\n    }\n}\nexport function createSearchOverlay(options) {\n    const { widgetChanged, overlayState, onCaseSensitiveToggled, onRegexToggled, onHightlightNext, onHighlightPrevious, onStartQuery, onReplaceCurrent, onReplaceAll, onEndSearch, isReadOnly, hasOutputs, translator } = options;\n    const widget = ReactWidget.create(React.createElement(UseSignal, { signal: widgetChanged, initialArgs: overlayState }, (_, args) => {\n        return (React.createElement(SearchOverlay, { onCaseSensitiveToggled: onCaseSensitiveToggled, onRegexToggled: onRegexToggled, onHightlightNext: onHightlightNext, onHighlightPrevious: onHighlightPrevious, onStartQuery: onStartQuery, onEndSearch: onEndSearch, onReplaceCurrent: onReplaceCurrent, onReplaceAll: onReplaceAll, overlayState: args, isReadOnly: isReadOnly, hasOutputs: hasOutputs, translator: translator }));\n    }));\n    widget.addClass(OVERLAY_CLASS);\n    return widget;\n}\nvar Private;\n(function (Private) {\n    function parseQuery(queryString, caseSensitive, regex) {\n        const flag = caseSensitive ? 'g' : 'gi';\n        // escape regex characters in query if its a string search\n        const queryText = regex\n            ? queryString\n            : queryString.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\n        let ret;\n        ret = new RegExp(queryText, flag);\n        if (ret.test('')) {\n            ret = /x^/;\n        }\n        return ret;\n    }\n    Private.parseQuery = parseQuery;\n    function regexEqual(a, b) {\n        if (!a || !b) {\n            return false;\n        }\n        return (a.source === b.source &&\n            a.global === b.global &&\n            a.ignoreCase === b.ignoreCase &&\n            a.multiline === b.multiline);\n    }\n    Private.regexEqual = regexEqual;\n})(Private || (Private = {}));\n//# sourceMappingURL=searchoverlay.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { createSearchOverlay } from './searchoverlay';\nimport { MainAreaWidget } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Signal } from '@lumino/signaling';\nimport { Widget } from '@lumino/widgets';\nimport { NotebookPanel } from '@jupyterlab/notebook';\n/**\n * Represents a search on a single widget.\n */\nexport class SearchInstance {\n    constructor(widget, searchProvider, translator) {\n        this._displayState = {\n            currentIndex: 0,\n            totalMatches: 0,\n            caseSensitive: false,\n            useRegex: false,\n            searchText: '',\n            query: null,\n            errorMessage: '',\n            searchInputFocused: true,\n            replaceInputFocused: false,\n            forceFocus: true,\n            replaceText: '',\n            replaceEntryShown: false,\n            filters: { output: true, selectedCells: false },\n            filtersOpen: false\n        };\n        this._displayUpdateSignal = new Signal(this);\n        this._isDisposed = false;\n        this._disposed = new Signal(this);\n        this.translator = translator || nullTranslator;\n        this._widget = widget;\n        this._activeProvider = searchProvider;\n        const initialQuery = this._activeProvider.getInitialQuery(this._widget);\n        this._displayState.searchText = initialQuery || '';\n        this._searchWidget = createSearchOverlay({\n            widgetChanged: this._displayUpdateSignal,\n            overlayState: this._displayState,\n            onCaseSensitiveToggled: this._onCaseSensitiveToggled.bind(this),\n            onRegexToggled: this._onRegexToggled.bind(this),\n            onHightlightNext: this._highlightNext.bind(this),\n            onHighlightPrevious: this._highlightPrevious.bind(this),\n            onStartQuery: this._startQuery.bind(this),\n            onReplaceCurrent: this._replaceCurrent.bind(this),\n            onReplaceAll: this._replaceAll.bind(this),\n            onEndSearch: this.dispose.bind(this),\n            isReadOnly: this._activeProvider.isReadOnly,\n            hasOutputs: this._activeProvider.hasOutputs || false,\n            translator: this.translator\n        });\n        this._widget.disposed.connect(() => {\n            this.dispose();\n        });\n        this._searchWidget.disposed.connect(() => {\n            this._widget.activate();\n            this.dispose();\n        });\n        // TODO: this does not update if the toolbar changes height.\n        if (this._widget instanceof MainAreaWidget) {\n            // Offset the position of the search widget to not cover the toolbar.\n            this._searchWidget.node.style.top = `${this._widget.toolbar.node.clientHeight}px`;\n        }\n        if (this._widget instanceof NotebookPanel) {\n            this._widget.content.activeCellChanged.connect(() => {\n                if (this._displayState.query &&\n                    this._displayState.filters.selectedCells) {\n                    void this._startQuery(this._displayState.query, this._displayState.filters);\n                }\n            });\n        }\n        this._displaySearchWidget();\n    }\n    /**\n     * The search widget.\n     */\n    get searchWidget() {\n        return this._searchWidget;\n    }\n    /**\n     * The search provider.\n     */\n    get provider() {\n        return this._activeProvider;\n    }\n    /**\n     * Focus the search widget input.\n     */\n    focusInput() {\n        this._displayState.forceFocus = true;\n        this._displayState.searchInputFocused = true;\n        // Trigger a rerender without resetting the forceFocus.\n        this._displayUpdateSignal.emit(this._displayState);\n        this._displayState.forceFocus = false;\n    }\n    /**\n     * If there is a replace box, show it.\n     */\n    showReplace() {\n        this._displayState.replaceEntryShown = true;\n    }\n    /**\n     * Updates the match index and total display in the search widget.\n     */\n    updateIndices() {\n        this._displayState.totalMatches = this._activeProvider.matches.length;\n        this._displayState.currentIndex = this._activeProvider.currentMatchIndex;\n        this._updateDisplay();\n    }\n    _updateDisplay() {\n        // Reset the focus attribute to make sure we don't steal focus.\n        this._displayState.forceFocus = false;\n        // Trigger a rerender\n        this._displayUpdateSignal.emit(this._displayState);\n    }\n    async _startQuery(query, filters) {\n        // save the last query (or set it to the current query if this is the first)\n        if (this._activeProvider && this._displayState.query) {\n            await this._activeProvider.endQuery();\n        }\n        this._displayState.query = query;\n        this._displayState.filters = filters;\n        await this._activeProvider.startQuery(query, this._widget, filters);\n        this.updateIndices();\n        // this signal should get injected when the widget is\n        // created and hooked up to react!\n        this._activeProvider.changed.connect(this.updateIndices, this);\n    }\n    async _replaceCurrent(newText) {\n        if (this._activeProvider && this._displayState.query) {\n            await this._activeProvider.replaceCurrentMatch(newText);\n            this.updateIndices();\n        }\n    }\n    async _replaceAll(newText) {\n        if (this._activeProvider && this._displayState.query) {\n            await this._activeProvider.replaceAllMatches(newText);\n            this.updateIndices();\n        }\n    }\n    /**\n     * Dispose of the resources held by the search instance.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        // If a query hasn't been executed yet, no need to call endSearch\n        if (this._displayState.query) {\n            void this._activeProvider.endSearch();\n        }\n        this._searchWidget.dispose();\n        this._disposed.emit(undefined);\n        Signal.clearData(this);\n    }\n    /**\n     * Test if the object has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A signal emitted when the object is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Display search widget.\n     */\n    _displaySearchWidget() {\n        if (!this._searchWidget.isAttached) {\n            Widget.attach(this._searchWidget, this._widget.node);\n        }\n    }\n    async _highlightNext() {\n        if (!this._displayState.query) {\n            return;\n        }\n        await this._activeProvider.highlightNext();\n        this.updateIndices();\n    }\n    async _highlightPrevious() {\n        if (!this._displayState.query) {\n            return;\n        }\n        await this._activeProvider.highlightPrevious();\n        this.updateIndices();\n    }\n    _onCaseSensitiveToggled() {\n        this._displayState.caseSensitive = !this._displayState.caseSensitive;\n        this._updateDisplay();\n    }\n    _onRegexToggled() {\n        this._displayState.useRegex = !this._displayState.useRegex;\n        this._updateDisplay();\n    }\n}\n//# sourceMappingURL=searchinstance.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { Signal } from '@lumino/signaling';\nexport class SearchProviderRegistry {\n    constructor() {\n        this._changed = new Signal(this);\n        this._providerMap = new Map();\n    }\n    /**\n     * Add a provider to the registry.\n     *\n     * @param key - The provider key.\n     * @returns A disposable delegate that, when disposed, deregisters the given search provider\n     */\n    register(key, provider) {\n        this._providerMap.set(key, provider);\n        this._changed.emit();\n        return new DisposableDelegate(() => {\n            this._providerMap.delete(key);\n            this._changed.emit();\n        });\n    }\n    /**\n     * Returns a matching provider for the widget.\n     *\n     * @param widget - The widget to search over.\n     * @returns the search provider, or undefined if none exists.\n     */\n    getProviderForWidget(widget) {\n        return this._findMatchingProvider(this._providerMap, widget);\n    }\n    /**\n     * Signal that emits when a new search provider has been registered\n     * or removed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    _findMatchingProvider(providerMap, widget) {\n        // iterate through all providers and ask each one if it can search on the\n        // widget.\n        for (const P of providerMap.values()) {\n            if (P.canSearchOn(widget)) {\n                return new P();\n            }\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=searchproviderregistry.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The search provider registry token.\n */\nexport const ISearchProviderRegistry = new Token('@jupyterlab/documentsearch:ISearchProviderRegistry');\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Signal } from '@lumino/signaling';\nimport { Widget } from '@lumino/widgets';\nexport const FOUND_CLASSES = ['cm-string', 'cm-overlay', 'cm-searching'];\nconst SELECTED_CLASSES = ['CodeMirror-selectedtext'];\nexport class GenericSearchProvider {\n    constructor() {\n        /**\n         * Set to true if the widget under search is read-only, false\n         * if it is editable.  Will be used to determine whether to show\n         * the replace option.\n         */\n        this.isReadOnly = true;\n        /**\n         * Set whether or not this will wrap to the beginning\n         * or end of the document on invocations of highlightNext or highlightPrevious, respectively\n         */\n        this.isSubProvider = false;\n        this._matches = [];\n        this._mutationObserver = new MutationObserver(this._onWidgetChanged.bind(this));\n        this._changed = new Signal(this);\n    }\n    /**\n     * Get an initial query value if applicable so that it can be entered\n     * into the search box as an initial query\n     *\n     * @returns Initial value used to populate the search box.\n     */\n    getInitialQuery(searchTarget) {\n        return '';\n    }\n    /**\n     * Initialize the search using the provided options.  Should update the UI\n     * to highlight all matches and \"select\" whatever the first match should be.\n     *\n     * @param query A RegExp to be use to perform the search\n     * @param searchTarget The widget to be searched\n     * @param [filters={}] Filter parameters to pass to provider\n     *\n     * @returns A promise that resolves with a list of all matches\n     */\n    async startQuery(query, searchTarget, filters = {}) {\n        const that = this; // eslint-disable-line\n        // No point in removing overlay in the middle of the search\n        await this.endQuery(false);\n        this._widget = searchTarget;\n        this._query = query;\n        this._mutationObserver.disconnect();\n        const matches = [];\n        const walker = document.createTreeWalker(this._widget.node, NodeFilter.SHOW_TEXT, {\n            acceptNode: node => {\n                // Filter subtrees of UNSUPPORTED_ELEMENTS and nodes that\n                // do not contain our search text\n                let parentElement = node.parentElement;\n                while (parentElement !== this._widget.node) {\n                    if (parentElement.nodeName in\n                        GenericSearchProvider.UNSUPPORTED_ELEMENTS) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                    parentElement = parentElement.parentElement;\n                }\n                return that._query.test(node.textContent)\n                    ? NodeFilter.FILTER_ACCEPT\n                    : NodeFilter.FILTER_REJECT;\n            }\n        }, false);\n        const nodes = [];\n        const originalNodes = [];\n        // We MUST gather nodes first, otherwise the updates below will find each result twice\n        let node = walker.nextNode();\n        while (node) {\n            nodes.push(node);\n            /* We store them here as we want to avoid saving a modified one\n             * This happens with something like this: <pre><span>Hello</span> world</pre> and looking for o\n             * The o in world is found after the o in hello which means the pre could have been modified already\n             * While there may be a better data structure to do this for performance, this was easy to reason about.\n             */\n            originalNodes.push(node.parentElement.cloneNode(true));\n            node = walker.nextNode();\n        }\n        // We'll need to copy the regexp to ensure its 'g' and that we start the index count from 0\n        const flags = this._query.flags.indexOf('g') === -1 ? query.flags + 'g' : query.flags;\n        nodes.forEach((node, nodeIndex) => {\n            const q = new RegExp(query.source, flags);\n            const subsections = [];\n            let match = q.exec(node.textContent);\n            while (match) {\n                subsections.push({\n                    start: match.index,\n                    end: match.index + match[0].length,\n                    text: match[0]\n                });\n                match = q.exec(node.textContent);\n            }\n            const originalNode = originalNodes[nodeIndex];\n            const originalLength = node.textContent.length; // Node length will change below\n            let lastNodeAdded = null;\n            // Go backwards as index may change if we go forwards\n            const newMatches = [];\n            for (let idx = subsections.length - 1; idx >= 0; --idx) {\n                const { start, end, text } = subsections[idx];\n                // TODO: support tspan for svg when svg support is added\n                const spannedNode = document.createElement('span');\n                spannedNode.classList.add(...FOUND_CLASSES);\n                spannedNode.textContent = text;\n                // Splice the text out before we add it back in with a span\n                node.textContent = `${node.textContent.slice(0, start)}${node.textContent.slice(end)}`;\n                // Are we replacing somewhere in the middle?\n                if ((node === null || node === void 0 ? void 0 : node.nodeType) == Node.TEXT_NODE) {\n                    const endText = node.splitText(start);\n                    node.parentNode.insertBefore(spannedNode, endText);\n                    // Are we replacing from the start?\n                }\n                else if (start === 0) {\n                    node.parentNode.prepend(spannedNode);\n                    // Are we replacing at the end?\n                }\n                else if (end === originalLength) {\n                    node.parentNode.append(spannedNode);\n                    // Are the two results are adjacent to each other?\n                }\n                else if (lastNodeAdded && end === subsections[idx + 1].start) {\n                    node.parentNode.insertBefore(spannedNode, lastNodeAdded);\n                }\n                lastNodeAdded = spannedNode;\n                newMatches.unshift({\n                    text,\n                    fragment: '',\n                    line: 0,\n                    column: 0,\n                    index: -1,\n                    // GenericSearchFields\n                    matchesIndex: -1,\n                    indexInOriginal: idx,\n                    spanElement: spannedNode,\n                    originalNode\n                });\n            }\n            matches.push(...newMatches);\n        });\n        matches.forEach((match, idx) => {\n            // This may be changed when this is a subprovider :/\n            match.index = idx;\n            // TODO: matchesIndex is declared as readonly. Why are we setting it here?\n            match.matchesIndex = idx;\n        });\n        if (!this.isSubProvider && matches.length > 0) {\n            this._currentMatch = matches[0];\n        }\n        // Watch for future changes:\n        this._mutationObserver.observe(this._widget.node, \n        // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserverInit\n        {\n            attributes: false,\n            characterData: true,\n            childList: true,\n            subtree: true\n        });\n        this._matches = matches;\n        return this._matches;\n    }\n    refreshOverlay() {\n        // We don't have an overlay, we are directly changing the DOM\n    }\n    /**\n     * Clears state of a search provider to prepare for startQuery to be called\n     * in order to start a new query or refresh an existing one.\n     *\n     * @returns A promise that resolves when the search provider is ready to\n     * begin a new search.\n     */\n    async endQuery(removeOverlay = true) {\n        this._matches.forEach(match => {\n            // We already took care of this parent with another match\n            if (match.indexInOriginal !== 0) {\n                return;\n            }\n            match.spanElement.parentElement.replaceWith(match.originalNode);\n        });\n        this._matches = [];\n        this._currentMatch = null;\n        this._mutationObserver.disconnect();\n    }\n    /**\n     * Resets UI state, removes all matches.\n     *\n     * @returns A promise that resolves when all state has been cleaned up.\n     */\n    async endSearch() {\n        return this.endQuery();\n    }\n    /**\n     * Move the current match indicator to the next match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightNext() {\n        return this._highlightNext(false);\n    }\n    /**\n     * Move the current match indicator to the previous match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightPrevious() {\n        return this._highlightNext(true);\n    }\n    _highlightNext(reverse) {\n        if (this._matches.length === 0) {\n            return undefined;\n        }\n        if (!this._currentMatch) {\n            this._currentMatch = reverse\n                ? this._matches[this.matches.length - 1]\n                : this._matches[0];\n        }\n        else {\n            this._currentMatch.spanElement.classList.remove(...SELECTED_CLASSES);\n            let nextIndex = reverse\n                ? this._currentMatch.matchesIndex - 1\n                : this._currentMatch.matchesIndex + 1;\n            // When we are a subprovider, don't loop\n            if (this.isSubProvider) {\n                if (nextIndex < 0 || nextIndex >= this._matches.length) {\n                    this._currentMatch = null;\n                    return undefined;\n                }\n            }\n            // Cheap way to make this a circular buffer\n            nextIndex = (nextIndex + this._matches.length) % this._matches.length;\n            this._currentMatch = this._matches[nextIndex];\n        }\n        if (this._currentMatch) {\n            this._currentMatch.spanElement.classList.add(...SELECTED_CLASSES);\n            // If not in view, scroll just enough to see it\n            if (!elementInViewport(this._currentMatch.spanElement)) {\n                this._currentMatch.spanElement.scrollIntoView(reverse);\n            }\n            this._currentMatch.spanElement.focus();\n        }\n        return this._currentMatch;\n    }\n    /**\n     * Replace the currently selected match with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText) {\n        return Promise.resolve(false);\n    }\n    /**\n     * Replace all matches in the notebook with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceAllMatches(newText) {\n        // This is read only, but we could loosen this in theory for input boxes...\n        return Promise.resolve(false);\n    }\n    /**\n     * Report whether or not this provider has the ability to search on the given object\n     */\n    static canSearchOn(domain) {\n        return domain instanceof Widget;\n    }\n    /**\n     * The same list of matches provided by the startQuery promise resolution\n     */\n    get matches() {\n        // Ensure that no other fn can overwrite matches index property\n        // We shallow clone each node\n        return this._matches\n            ? this._matches.map(m => Object.assign({}, m))\n            : this._matches;\n    }\n    /**\n     * Signal indicating that something in the search has changed, so the UI should update\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The current index of the selected match.\n     */\n    get currentMatchIndex() {\n        if (!this._currentMatch) {\n            return null;\n        }\n        return this._currentMatch.index;\n    }\n    get currentMatch() {\n        return this._currentMatch;\n    }\n    clearSelection() {\n        return;\n    }\n    async _onWidgetChanged(mutations, observer) {\n        // This is typically cheap, but we do not control the rate of change or size of the output\n        await this.startQuery(this._query, this._widget);\n        this._changed.emit(undefined);\n    }\n}\n/**\n * We choose opt out as most node types should be searched (e.g. script).\n * Even nodes like <data>, could have textContent we care about.\n *\n * Note: nodeName is capitalized, so we do the same here\n */\nGenericSearchProvider.UNSUPPORTED_ELEMENTS = {\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Document_metadata\n    BASE: true,\n    HEAD: true,\n    LINK: true,\n    META: true,\n    STYLE: true,\n    TITLE: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Sectioning_root\n    BODY: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Content_sectioning\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Text_content\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Inline_text_semantics\n    // Above is searched\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Image_and_multimedia\n    AREA: true,\n    AUDIO: true,\n    IMG: true,\n    MAP: true,\n    TRACK: true,\n    VIDEO: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Embedded_content\n    APPLET: true,\n    EMBED: true,\n    IFRAME: true,\n    NOEMBED: true,\n    OBJECT: true,\n    PARAM: true,\n    PICTURE: true,\n    SOURCE: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Scripting\n    CANVAS: true,\n    NOSCRIPT: true,\n    SCRIPT: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Demarcating_edits\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Table_content\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Forms\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Interactive_elements\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Web_Components\n    // Above is searched\n    // Other:\n    SVG: true\n};\nfunction elementInViewport(el) {\n    const boundingClientRect = el.getBoundingClientRect();\n    return (boundingClientRect.top >= 0 &&\n        boundingClientRect.bottom <=\n            (window.innerHeight || document.documentElement.clientHeight) &&\n        boundingClientRect.left >= 0 &&\n        boundingClientRect.right <=\n            (window.innerWidth || document.documentElement.clientWidth));\n}\n//# sourceMappingURL=genericsearchprovider.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { MainAreaWidget } from '@jupyterlab/apputils';\nimport { CodeMirrorEditor } from '@jupyterlab/codemirror';\nimport { FileEditor } from '@jupyterlab/fileeditor';\nimport * as CodeMirror from 'codemirror';\nimport { Signal } from '@lumino/signaling';\nexport class CodeMirrorSearchProvider {\n    constructor() {\n        /**\n         * Set to true if the widget under search is read-only, false\n         * if it is editable.  Will be used to determine whether to show\n         * the replace option.\n         */\n        this.isReadOnly = false;\n        /**\n         * Set whether or not the CodemirrorSearchProvider will wrap to the beginning\n         * or end of the document on invocations of highlightNext or highlightPrevious, respectively\n         */\n        this.isSubProvider = false;\n        this._matchState = {};\n        this._changed = new Signal(this);\n    }\n    /**\n     * Get an initial query value if applicable so that it can be entered\n     * into the search box as an initial query\n     *\n     * @returns Initial value used to populate the search box.\n     */\n    getInitialQuery(searchTarget) {\n        const cm = searchTarget.content.editor;\n        const selection = cm.doc.getSelection();\n        // if there are newlines, just return empty string\n        return selection.search(/\\r?\\n|\\r/g) === -1 ? selection : '';\n    }\n    /**\n     * Initialize the search using the provided options.  Should update the UI\n     * to highlight all matches and \"select\" whatever the first match should be.\n     *\n     * @param query A RegExp to be use to perform the search\n     * @param searchTarget The widget to be searched\n     * @param [filters={}] Filter parameters to pass to provider\n     *\n     * @returns A promise that resolves with a list of all matches\n     */\n    async startQuery(query, searchTarget, filters = {}) {\n        if (!CodeMirrorSearchProvider.canSearchOn(searchTarget)) {\n            throw new Error('Cannot find Codemirror instance to search');\n        }\n        // canSearchOn is a type guard that guarantees the type of .editor\n        this._cm = searchTarget.content.editor;\n        return this._startQuery(query);\n    }\n    /**\n     * Initialize the search using a CodeMirrorEditor object.\n     */\n    async startQueryCodeMirror(query, searchTarget) {\n        this._cm = searchTarget;\n        return this._startQuery(query, false);\n    }\n    refreshOverlay() {\n        this._refreshOverlay();\n    }\n    async _startQuery(query, refreshOverlay = true) {\n        // no point in removing overlay in the middle of the search\n        await this.endQuery(false);\n        this._query = query;\n        CodeMirror.on(this._cm.doc, 'change', this._onDocChanged.bind(this));\n        if (refreshOverlay) {\n            this._refreshOverlay();\n        }\n        this._setInitialMatches(query);\n        const matches = this._parseMatchesFromState();\n        if (matches.length === 0) {\n            return [];\n        }\n        if (!this.isSubProvider) {\n            const cursorMatch = this._findNext(false);\n            const match = cursorMatch &&\n                this._matchState[cursorMatch.from.line][cursorMatch.from.ch];\n            this._currentMatch = match;\n        }\n        return matches;\n    }\n    /**\n     * Clears state of a search provider to prepare for startQuery to be called\n     * in order to start a new query or refresh an existing one.\n     *\n     * @returns A promise that resolves when the search provider is ready to\n     * begin a new search.\n     */\n    async endQuery(removeOverlay = true) {\n        this._matchState = {};\n        this._currentMatch = null;\n        if (removeOverlay) {\n            this._cm.removeOverlay(this._overlay);\n        }\n        const from = this._cm.getCursor('from');\n        const to = this._cm.getCursor('to');\n        // Setting a reverse selection to allow search-as-you-type to maintain the\n        // current selected match.  See comment in _findNext for more details.\n        if (from !== to) {\n            this._cm.setSelection({\n                start: this._toEditorPos(to),\n                end: this._toEditorPos(from)\n            });\n        }\n        CodeMirror.off(this._cm.doc, 'change', this._onDocChanged.bind(this));\n    }\n    /**\n     * Resets UI state, removes all matches.\n     *\n     * @returns A promise that resolves when all state has been cleaned up.\n     */\n    async endSearch() {\n        if (!this.isSubProvider) {\n            this._cm.focus();\n        }\n        return this.endQuery();\n    }\n    /**\n     * Move the current match indicator to the next match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightNext() {\n        const cursorMatch = this._findNext(false);\n        if (!cursorMatch) {\n            return;\n        }\n        const match = this._matchState[cursorMatch.from.line][cursorMatch.from.ch];\n        this._currentMatch = match;\n        return match;\n    }\n    /**\n     * Move the current match indicator to the previous match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightPrevious() {\n        const cursorMatch = this._findNext(true);\n        if (!cursorMatch) {\n            return;\n        }\n        const match = this._matchState[cursorMatch.from.line][cursorMatch.from.ch];\n        this._currentMatch = match;\n        return match;\n    }\n    /**\n     * Replace the currently selected match with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText) {\n        // If the current selection exactly matches the current match,\n        // replace it.  Otherwise, just select the next match after the cursor.\n        let replaceOccurred = false;\n        if (this._currentMatchIsSelected()) {\n            const cursor = this._cm.getSearchCursor(this._query, this._cm.getCursor('from'), !this._query.ignoreCase);\n            if (!cursor.findNext()) {\n                return replaceOccurred;\n            }\n            replaceOccurred = true;\n            cursor.replace(newText);\n        }\n        await this.highlightNext();\n        return replaceOccurred;\n    }\n    /**\n     * Replace all matches in the notebook with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceAllMatches(newText) {\n        let replaceOccurred = false;\n        return new Promise((resolve, _) => {\n            this._cm.operation(() => {\n                const cursor = this._cm.getSearchCursor(this._query, undefined, !this._query.ignoreCase);\n                while (cursor.findNext()) {\n                    replaceOccurred = true;\n                    cursor.replace(newText);\n                }\n                this._matchState = {};\n                this._currentMatch = null;\n                resolve(replaceOccurred);\n            });\n        });\n    }\n    /**\n     * Report whether or not this provider has the ability to search on the given object\n     */\n    static canSearchOn(domain) {\n        return (domain instanceof MainAreaWidget &&\n            domain.content instanceof FileEditor &&\n            domain.content.editor instanceof CodeMirrorEditor);\n    }\n    /**\n     * The same list of matches provided by the startQuery promise resolution\n     */\n    get matches() {\n        return this._parseMatchesFromState();\n    }\n    get currentMatch() {\n        return this._currentMatch;\n    }\n    /**\n     * Signal indicating that something in the search has changed, so the UI should update\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The current index of the selected match.\n     */\n    get currentMatchIndex() {\n        if (!this._currentMatch) {\n            return null;\n        }\n        return this._currentMatch.index;\n    }\n    clearSelection() {\n        return undefined;\n    }\n    get editor() {\n        return this._cm;\n    }\n    _onDocChanged(_, changeObj) {\n        var _a, _b;\n        // If we get newlines added/removed, the line numbers across the\n        // match state are all shifted, so here we need to recalculate it\n        if (changeObj.text.length > 1 || ((_b = (_a = changeObj.removed) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 1) {\n            this._setInitialMatches(this._query);\n            this._changed.emit(undefined);\n        }\n    }\n    _refreshOverlay() {\n        this._cm.operation(() => {\n            // clear search first\n            this._cm.removeOverlay(this._overlay);\n            this._overlay = this._getSearchOverlay();\n            this._cm.addOverlay(this._overlay);\n            this._changed.emit(undefined);\n        });\n    }\n    /**\n     * Do a full search on the entire document.\n     *\n     * This manually constructs the initial match state across the whole\n     * document. This must be done manually because the codemirror overlay\n     * is lazy-loaded, so it will only tokenize lines that are in or near\n     * the viewport.  This is sufficient for efficiently maintaining the\n     * state when changes are made to the document, as changes occur in or\n     * near the viewport, but to scan the whole document, a manual search\n     * across the entire content is required.\n     *\n     * @param query The search term\n     */\n    _setInitialMatches(query) {\n        this._matchState = {};\n        const start = CodeMirror.Pos(this._cm.doc.firstLine(), 0);\n        const end = CodeMirror.Pos(this._cm.doc.lastLine());\n        const content = this._cm.doc.getRange(start, end);\n        const lines = content.split('\\n');\n        const totalMatchIndex = 0;\n        lines.forEach((line, lineNumber) => {\n            query.lastIndex = 0;\n            let match = query.exec(line);\n            while (match) {\n                const col = match.index;\n                const matchObj = {\n                    text: match[0],\n                    line: lineNumber,\n                    column: col,\n                    fragment: line,\n                    index: totalMatchIndex\n                };\n                if (!this._matchState[lineNumber]) {\n                    this._matchState[lineNumber] = {};\n                }\n                this._matchState[lineNumber][col] = matchObj;\n                match = query.exec(line);\n            }\n        });\n    }\n    _getSearchOverlay() {\n        return {\n            /**\n             * Token function is called when a line needs to be processed -\n             * when the overlay is initially created, it's called on all lines;\n             * when a line is modified and needs to be re-evaluated, it's called\n             * on just that line.\n             *\n             * This implementation of the token function both constructs/maintains\n             * the overlay and keeps track of the match state as the document is\n             * updated while a search is active.\n             */\n            token: (stream) => {\n                const currentPos = stream.pos;\n                this._query.lastIndex = currentPos;\n                const lineText = stream.string;\n                const match = this._query.exec(lineText);\n                const line = stream.lineOracle.line;\n                // If starting at position 0, the tokenization of this line has just started.\n                // Blow away everything on this line in the state so it can be updated.\n                if (stream.start === currentPos &&\n                    currentPos === 0 &&\n                    !!this._matchState[line]) {\n                    this._matchState[line] = {};\n                }\n                if (match && match.index === currentPos) {\n                    // found match, add it to state\n                    const matchLength = match[0].length;\n                    const matchObj = {\n                        text: lineText.substr(currentPos, matchLength),\n                        line: line,\n                        column: currentPos,\n                        fragment: lineText,\n                        index: 0 // fill in index when flattening, later\n                    };\n                    if (!this._matchState[line]) {\n                        this._matchState[line] = {};\n                    }\n                    this._matchState[line][currentPos] = matchObj;\n                    // move the stream along and return searching style for the token\n                    stream.pos += matchLength || 1;\n                    // if the last thing on the line was a match, make sure we still\n                    // emit the changed signal so the display can pick up the updates\n                    if (stream.eol()) {\n                        this._changed.emit(undefined);\n                    }\n                    return 'searching';\n                }\n                else if (match) {\n                    // there's a match in the stream, advance the stream to its position\n                    stream.pos = match.index;\n                }\n                else {\n                    // no matches, consume the rest of the stream\n                    this._changed.emit(undefined);\n                    stream.skipToEnd();\n                }\n            }\n        };\n    }\n    _findNext(reverse) {\n        return this._cm.operation(() => {\n            const caseSensitive = this._query.ignoreCase;\n            // In order to support search-as-you-type, we needed a way to allow the first\n            // match to be selected when a search is started, but prevent the selected\n            // search to move for each new keypress.  To do this, when a search is ended,\n            // the cursor is reversed, putting the head at the 'from' position.  When a new\n            // search is started, the cursor we want is at the 'from' position, so that the same\n            // match is selected when the next key is entered (if it is still a match).\n            //\n            // When toggling through a search normally, the cursor is always set in the forward\n            // direction, so head is always at the 'to' position.  That way, if reverse = false,\n            // the search proceeds from the 'to' position during normal toggling.  If reverse = true,\n            // the search always proceeds from the 'anchor' position, which is at the 'from'.\n            const cursorToGet = reverse ? 'anchor' : 'head';\n            const lastPosition = this._cm.getCursor(cursorToGet);\n            const position = this._toEditorPos(lastPosition);\n            let cursor = this._cm.getSearchCursor(this._query, lastPosition, !caseSensitive);\n            if (!cursor.find(reverse)) {\n                // if we don't want to loop, no more matches found, reset the cursor and exit\n                if (this.isSubProvider) {\n                    this._cm.setCursorPosition(position, { scroll: false });\n                    this._currentMatch = null;\n                    return null;\n                }\n                // if we do want to loop, try searching from the bottom/top\n                const startOrEnd = reverse\n                    ? CodeMirror.Pos(this._cm.lastLine())\n                    : CodeMirror.Pos(this._cm.firstLine(), 0);\n                cursor = this._cm.getSearchCursor(this._query, startOrEnd, !caseSensitive);\n                if (!cursor.find(reverse)) {\n                    return null;\n                }\n            }\n            const fromPos = cursor.from();\n            const toPos = cursor.to();\n            const selRange = {\n                start: {\n                    line: fromPos.line,\n                    column: fromPos.ch\n                },\n                end: {\n                    line: toPos.line,\n                    column: toPos.ch\n                }\n            };\n            this._cm.setSelection(selRange);\n            this._cm.scrollIntoView({\n                from: fromPos,\n                to: toPos\n            }, 100);\n            return {\n                from: fromPos,\n                to: toPos\n            };\n        });\n    }\n    _parseMatchesFromState() {\n        let index = 0;\n        // Flatten state map and update the index of each match\n        const matches = Object.keys(this._matchState).reduce((result, lineNumber) => {\n            const lineKey = parseInt(lineNumber, 10);\n            const lineMatches = this._matchState[lineKey];\n            Object.keys(lineMatches).forEach((pos) => {\n                const posKey = parseInt(pos, 10);\n                const match = lineMatches[posKey];\n                match.index = index;\n                index += 1;\n                result.push(match);\n            });\n            return result;\n        }, []);\n        return matches;\n    }\n    _toEditorPos(posIn) {\n        return {\n            line: posIn.line,\n            column: posIn.ch\n        };\n    }\n    _currentMatchIsSelected() {\n        if (!this._currentMatch) {\n            return false;\n        }\n        const currentSelection = this._cm.getSelection();\n        const currentSelectionLength = currentSelection.end.column - currentSelection.start.column;\n        const selectionIsOneLine = currentSelection.start.line === currentSelection.end.line;\n        return (this._currentMatch.line === currentSelection.start.line &&\n            this._currentMatch.column === currentSelection.start.column &&\n            this._currentMatch.text.length === currentSelectionLength &&\n            selectionIsOneLine);\n    }\n}\nexport class SearchState {\n}\n//# sourceMappingURL=codemirrorsearchprovider.js.map","import { CodeMirrorSearchProvider } from './codemirrorsearchprovider';\nimport { GenericSearchProvider } from './genericsearchprovider';\nimport { MarkdownCell, CodeCell } from '@jupyterlab/cells';\nimport { NotebookPanel } from '@jupyterlab/notebook';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { Signal } from '@lumino/signaling';\nimport CodeMirror from 'codemirror';\nexport class NotebookSearchProvider {\n    constructor() {\n        /**\n         * Set to true if the widget under search is read-only, false\n         * if it is editable.  Will be used to determine whether to show\n         * the replace option.\n         */\n        this.isReadOnly = false;\n        this.hasOutputs = true;\n        this._searchProviders = [];\n        this._unRenderedMarkdownCells = [];\n        this._cellsWithMatches = [];\n        this._changed = new Signal(this);\n    }\n    /**\n     * Get an initial query value if applicable so that it can be entered\n     * into the search box as an initial query\n     *\n     * @returns Initial value used to populate the search box.\n     */\n    getInitialQuery(searchTarget) {\n        var _a;\n        const activeCell = searchTarget.content.activeCell;\n        const selection = (_a = activeCell === null || activeCell === void 0 ? void 0 : activeCell.editor) === null || _a === void 0 ? void 0 : _a.doc.getSelection();\n        // if there are newlines, just return empty string\n        return (selection === null || selection === void 0 ? void 0 : selection.search(/\\r?\\n|\\r/g)) === -1 ? selection : '';\n    }\n    /**\n     * Initialize the search using the provided options. Should update the UI\n     * to highlight all matches and \"select\" whatever the first match should be.\n     *\n     * @param query A RegExp to be use to perform the search\n     * @param searchTarget The widget to be searched\n     * @param filters Filter parameters to pass to provider\n     *\n     * @returns A promise that resolves with a list of all matches\n     */\n    async startQuery(query, searchTarget, filters) {\n        this._searchTarget = searchTarget;\n        let cells = this._searchTarget.content.widgets;\n        this._filters =\n            !filters || Object.entries(filters).length === 0\n                ? { output: true, selectedCells: false }\n                : filters;\n        const selectedCells = cells.filter(cell => this._searchTarget.content.isSelectedOrActive(cell));\n        if (this._filters.selectedCells && selectedCells.length > 0) {\n            cells = selectedCells;\n        }\n        // hide the current notebook widget to prevent expensive layout re-calculation operations\n        this._searchTarget.hide();\n        let indexTotal = 0;\n        const allMatches = [];\n        // For each cell, create a search provider and collect the matches\n        for (const cell of cells) {\n            const cmEditor = cell.editor;\n            const cmSearchProvider = new CodeMirrorSearchProvider();\n            cmSearchProvider.isSubProvider = true;\n            // If a rendered MarkdownCell contains a match, unrender it so that\n            // CodeMirror can show the match(es).  If the MarkdownCell is not\n            // rendered, putting CodeMirror on the page, CodeMirror will not run\n            // the mode, which will prevent the search from occurring.\n            // Keep track so that the cell can be rerendered when the search is ended\n            // or if there are no matches\n            let cellShouldReRender = false;\n            if (cell instanceof MarkdownCell && cell.rendered) {\n                cell.rendered = false;\n                cellShouldReRender = true;\n            }\n            // Unhide hidden cells for the same reason as above\n            if (cell.inputHidden) {\n                cell.inputHidden = false;\n            }\n            // chain promises to ensure indexing is sequential\n            const matchesFromCell = await cmSearchProvider.startQueryCodeMirror(query, cmEditor);\n            if (cell instanceof MarkdownCell) {\n                if (matchesFromCell.length !== 0) {\n                    // un-render markdown cells with matches\n                    this._unRenderedMarkdownCells.push(cell);\n                }\n                else if (cellShouldReRender) {\n                    // was rendered previously, no need to refresh\n                    cell.rendered = true;\n                }\n            }\n            if (matchesFromCell.length !== 0) {\n                cmSearchProvider.refreshOverlay();\n                this._cellsWithMatches.push(cell);\n            }\n            // update the match indices to reflect the whole document index values\n            matchesFromCell.forEach(match => {\n                match.index = match.index + indexTotal;\n            });\n            indexTotal += matchesFromCell.length;\n            // search has been initialized, connect the changed signal\n            cmSearchProvider.changed.connect(this._onSearchProviderChanged, this);\n            allMatches.concat(matchesFromCell);\n            this._searchProviders.push({\n                cell: cell,\n                provider: cmSearchProvider\n            });\n            if (cell instanceof CodeCell && this._filters.output) {\n                const outputProivder = new GenericSearchProvider();\n                outputProivder.isSubProvider = true;\n                const matchesFromOutput = await outputProivder.startQuery(query, cell.outputArea);\n                matchesFromOutput.map(match => {\n                    match.index = match.index + indexTotal;\n                });\n                indexTotal += matchesFromOutput.length;\n                allMatches.concat(matchesFromOutput);\n                outputProivder.changed.connect(this._onSearchProviderChanged, this);\n                this._searchProviders.push({\n                    cell: cell,\n                    provider: outputProivder\n                });\n            }\n        }\n        // show the widget again, recalculation of layout will matter again\n        // and so that the next step will scroll correctly to the first match\n        this._searchTarget.show();\n        this._currentMatch = await this._stepNext(this._updatedCurrentProvider(false));\n        this._refreshCurrentCellEditor();\n        this._refreshCellsEditorsInBackground(this._cellsWithMatches);\n        return allMatches;\n    }\n    /**\n     * Gradually refresh cells in the background so that the user will not\n     * experience frozen interface, `n` cells at a time.\n     */\n    _refreshCellsEditorsInBackground(cells, n = 5) {\n        let i = 0;\n        const refreshNextNCells = () => {\n            for (let stop = i + n; i < stop && i < cells.length; i++) {\n                cells[i].editor.refresh();\n            }\n            if (i < cells.length) {\n                window.setTimeout(refreshNextNCells, 0);\n            }\n        };\n        window.setTimeout(refreshNextNCells, 0);\n    }\n    /**\n     * Refresh the editor in the cell for the current match.\n     */\n    _refreshCurrentCellEditor() {\n        const notebook = this._searchTarget.content;\n        notebook.activeCell.editor.refresh();\n    }\n    /**\n     * Clears state of a search provider to prepare for startQuery to be called\n     * in order to start a new query or refresh an existing one.\n     *\n     * @returns A promise that resolves when the search provider is ready to\n     * begin a new search.\n     */\n    async endQuery() {\n        this._searchTarget.hide();\n        const queriesEnded = [];\n        this._searchProviders.forEach(({ provider }) => {\n            queriesEnded.push(provider.endQuery());\n            provider.changed.disconnect(this._onSearchProviderChanged, this);\n        });\n        Signal.disconnectBetween(this._searchTarget.model.cells, this);\n        this._searchProviders = [];\n        this._currentProvider = null;\n        this._unRenderedMarkdownCells.forEach((cell) => {\n            // Guard against the case where markdown cells have been deleted\n            if (!cell.isDisposed) {\n                cell.rendered = true;\n            }\n        });\n        this._unRenderedMarkdownCells = [];\n        await Promise.all(queriesEnded);\n        this._searchTarget.show();\n        this._refreshCurrentCellEditor();\n        // re-render all non-markdown cells with matches (which were rendered, thus do not need refreshing)\n        this._refreshCellsEditorsInBackground(this._cellsWithMatches.filter((cell) => !(cell instanceof MarkdownCell)));\n        this._cellsWithMatches = [];\n    }\n    /**\n     * Resets UI state, removes all matches.\n     *\n     * @returns A promise that resolves when all state has been cleaned up.\n     */\n    async endSearch() {\n        this._searchTarget.hide();\n        Signal.disconnectBetween(this._searchTarget.model.cells, this);\n        const index = this._searchTarget.content.activeCellIndex;\n        const searchEnded = [];\n        this._searchProviders.forEach(({ provider }) => {\n            searchEnded.push(provider.endSearch());\n            provider.changed.disconnect(this._onSearchProviderChanged, this);\n        });\n        this._searchProviders = [];\n        this._currentProvider = null;\n        this._unRenderedMarkdownCells.forEach((cell) => {\n            cell.rendered = true;\n        });\n        this._unRenderedMarkdownCells = [];\n        this._searchTarget.content.activeCellIndex = index;\n        this._searchTarget.content.mode = 'edit';\n        this._currentMatch = null;\n        await Promise.all(searchEnded);\n        this._searchTarget.show();\n        this._refreshCurrentCellEditor();\n        this._searchTarget = null;\n        // re-render all non-markdown cells with matches (which were rendered, thus do not need refreshing)\n        this._refreshCellsEditorsInBackground(this._cellsWithMatches.filter((cell) => !(cell instanceof MarkdownCell)));\n        this._cellsWithMatches = [];\n    }\n    /**\n     * Move the current match indicator to the next match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightNext() {\n        this._currentMatch = await this._stepNext(this._updatedCurrentProvider(false));\n        return this._currentMatch;\n    }\n    /**\n     * Move the current match indicator to the previous match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightPrevious() {\n        this._currentMatch = await this._stepNext(this._updatedCurrentProvider(true), true);\n        return this._currentMatch;\n    }\n    /**\n     * Replace the currently selected match with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText) {\n        const notebook = this._searchTarget.content;\n        const editor = notebook.activeCell.editor;\n        let replaceOccurred = false;\n        if (this._currentMatchIsSelected(editor)) {\n            const { provider } = this._currentProvider;\n            replaceOccurred = await provider.replaceCurrentMatch(newText);\n            if (replaceOccurred) {\n                this._currentMatch = provider.currentMatch;\n                // If there was a replacement and there is another match, then the CodeMirrorSearchProvider\n                // already highlighted the next match, so we can return early to avoid skipping a match.\n                if (this._currentMatch) {\n                    return replaceOccurred;\n                }\n            }\n        }\n        await this.highlightNext();\n        return replaceOccurred;\n    }\n    /**\n     * Replace all matches in the notebook with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceAllMatches(newText) {\n        let replaceOccurred = false;\n        for (const index in this._searchProviders) {\n            const { provider } = this._searchProviders[index];\n            const singleReplaceOccurred = await provider.replaceAllMatches(newText);\n            replaceOccurred = singleReplaceOccurred ? true : replaceOccurred;\n        }\n        this._currentMatch = null;\n        return replaceOccurred;\n    }\n    /**\n     * Report whether or not this provider has the ability to search on the given object\n     */\n    static canSearchOn(domain) {\n        // check to see if the CMSearchProvider can search on the\n        // first cell, false indicates another editor is present\n        return domain instanceof NotebookPanel;\n    }\n    /**\n     * The same list of matches provided by the startQuery promise resolution\n     */\n    get matches() {\n        return [].concat(...this._getMatchesFromCells());\n    }\n    /**\n     * Signal indicating that something in the search has changed, so the UI should update\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The current index of the selected match.\n     */\n    get currentMatchIndex() {\n        if (!this._currentMatch) {\n            return null;\n        }\n        return this._currentMatch.index;\n    }\n    _updatedCurrentProvider(reverse) {\n        if (this._currentProvider &&\n            this._currentProvider.cell === this._searchTarget.content.activeCell) {\n            return this._currentProvider;\n        }\n        let provider;\n        if (!this._currentProvider) {\n            const find = reverse ? ArrayExt.findLastValue : ArrayExt.findFirstValue;\n            provider = find(this._searchProviders, provider => this._searchTarget.content.activeCell === provider.cell);\n        }\n        else {\n            const currentProviderIndex = ArrayExt.firstIndexOf(this._searchProviders, this._currentProvider);\n            const nextProviderIndex = ((reverse ? currentProviderIndex - 1 : currentProviderIndex + 1) +\n                this._searchProviders.length) %\n                this._searchProviders.length;\n            provider = this._searchProviders[nextProviderIndex];\n        }\n        this._currentProvider = provider;\n        return provider;\n    }\n    async _stepNext(currentSearchPair, reverse = false, steps = 0) {\n        const { provider } = currentSearchPair;\n        // highlightNext/Previous will not be able to search rendered MarkdownCells or\n        // hidden code cells, but that is okay here because in startQuery, we unrendered\n        // all cells with matches and unhide all cells\n        const match = reverse\n            ? await provider.highlightPrevious()\n            : await provider.highlightNext();\n        // If there was no match in this cell, try the next cell\n        if (!match) {\n            const providerIndex = this._searchProviders.indexOf(currentSearchPair);\n            const numProviders = this._searchProviders.length;\n            // We have looped around the whole notebook and have searched the original\n            // cell once more and found no matches.  Do not proceed with incrementing the\n            // active cell index so that the active cell doesn't change\n            if (steps === numProviders) {\n                return undefined;\n            }\n            const nextIndex = ((reverse ? providerIndex - 1 : providerIndex + 1) + numProviders) %\n                numProviders;\n            const nextSearchPair = this._searchProviders[nextIndex];\n            if (nextSearchPair.provider instanceof CodeMirrorSearchProvider) {\n                const editor = nextSearchPair.provider.editor;\n                // move the cursor of the next cell to the start/end of the cell so it can\n                // search the whole thing (but don't scroll because we haven't found anything yet)\n                const newPosCM = reverse\n                    ? CodeMirror.Pos(editor.lastLine())\n                    : CodeMirror.Pos(editor.firstLine(), 0);\n                const newPos = {\n                    line: newPosCM.line,\n                    column: newPosCM.ch\n                };\n                editor.setCursorPosition(newPos, { scroll: false });\n            }\n            this._currentProvider = nextSearchPair;\n            return this._stepNext(nextSearchPair, reverse, steps + 1);\n        }\n        const notebook = this._searchTarget.content;\n        notebook.activeCellIndex = notebook.widgets.indexOf(currentSearchPair.cell);\n        return match;\n    }\n    _getMatchesFromCells() {\n        let indexTotal = 0;\n        const result = [];\n        this._searchProviders.forEach(({ provider }) => {\n            const cellMatches = provider.matches;\n            cellMatches.forEach(match => {\n                match.index = match.index + indexTotal;\n            });\n            indexTotal += cellMatches.length;\n            result.push(cellMatches);\n        });\n        return result;\n    }\n    _onSearchProviderChanged() {\n        this._changed.emit(undefined);\n    }\n    _currentMatchIsSelected(cm) {\n        if (!this._currentMatch) {\n            return false;\n        }\n        const currentSelection = cm.getSelection();\n        const currentSelectionLength = currentSelection.end.column - currentSelection.start.column;\n        const selectionIsOneLine = currentSelection.start.line === currentSelection.end.line;\n        return (this._currentMatch.line === currentSelection.start.line &&\n            this._currentMatch.column === currentSelection.start.column &&\n            this._currentMatch.text.length === currentSelectionLength &&\n            selectionIsOneLine);\n    }\n}\n//# sourceMappingURL=notebooksearchprovider.js.map"],"sourceRoot":""}