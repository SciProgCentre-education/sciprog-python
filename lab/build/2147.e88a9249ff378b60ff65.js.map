{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/dialogs.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/savehandler.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/widgetmanager.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/manager.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/savingstatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/pathstatus.js"],"names":["FILE_DIALOG_CLASS","renameDialog","manager","oldPath","translator","trans","nullTranslator","load","showDialog","title","__","body","RenameHandler","focusNodeSelector","buttons","Dialog","label","then","result","value","isValidFileName","showErrorMessage","Error","basePath","PathExt","newPath","renameFile","nameOnSaveDialog","context","path","NameOnSaveHandler","model","dirty","contentsModel","renamed","rename","catch","error","message","indexOf","shouldOverwrite","overwrite","Promise","reject","options","resolve","button","accept","name","length","test","Widget","super","node","Private","createRenameNode","this","addClass","ext","inputNode","setSelectionRange","getElementsByTagName","document","createElement","existingLabel","textContent","existingPath","nameTitle","className","appendChild","createNameFileNode","checkboxNode","checked","checkbox","div","type","classList","add","addEventListener","nameFileOnSave","IDocumentManager","Token","SaveHandler","_autosaveTimer","_minInterval","_interval","_isActive","_inDialog","_isDisposed","_multiplier","_context","interval","saveInterval","fileChanged","connect","_setTimer","disposed","dispose","isDisposed","clearTimeout","Signal","window","setTimeout","_save","writable","start","Date","getTime","save","duration","Math","max","err","console","DocumentWidgetManager","_activateRequested","_registry","registry","factory","widget","createNew","_initializeWidget","factoryProperty","set","disposables","DisposableSet","each","widgetExtensions","extender","disposable","disposablesProperty","_onWidgetDisposed","adoptWidget","_onFileChanged","pathChanged","_onPathChanged","ready","setCaption","widgetsProperty","get","push","MessageLoop","closable","_widgetDisposed","contextProperty","widgetName","widgets","find","newWidget","all","toArray","map","onClose","onDelete","handler","msg","contextForWidget","emit","listCheckpoints","checkpoints","last","checkpoint","Time","last_modified","caption","readOnly","_a","shouldClose","ignoreSave","_maybeClose","saveAs","filter","fileName","saveLabel","displayType","ArrayExt","AttachedProperty","create","DocumentManager","_contexts","_autosave","_nameFileOnSave","_optionChanged","_autosaveInterval","services","_collaborative","collaborative","_dialogs","sessionDialogs","sessionContextDialogs","_docProviderFactory","docProviderFactory","_opener","opener","_when","when","widgetManager","activateRequested","_onActivateRequested","_widgetManager","_setBusy","setBusy","forEach","saveHandlerProperty","isActive","stop","closeWidgets","cloneWidget","close","_contextsForPath","c","x","fromFile","toDir","contents","copy","kernel","_createOrOpenDocument","sessions","stopIfNeeded","delete","deleteWidgets","widgetNames","defaultWidgetFactory","preferredWidgetFactories","f","findWidget","newUntitled","open","tempPath","UUID","cb","deleteFile","factoryName","normalizedPath","normalize","kernelPreference","modelDBFactory","getModelDBFactory","undefined","Context","autosaveInterval","autosave","_onContextDisposed","getWidgetFactory","which","widgetFactory","_widgetFactoryFor","modelName","getModelFactory","preference","getKernelPreference","_findContext","_createContext","initialize","createWidget","sender","args","SavingStatusComponent","props","TextItem","source","fileStatus","SavingStatus","VDomRenderer","opts","Model","docManager","status","PathStatusComponent","fullPath","VDomModel","_onStatusChange","_documentModel","newStatus","_status","stateChanged","_widget","_docManager","oldWidget","oldContext","saveState","disconnect","widgetContext","PathStatus","_onTitleChange","oldState","_getAllState","_name","_triggerChange","_onPathChange","_path","changed","newState"],"mappings":"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","file":"2147.e88a9249ff378b60ff65.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, showDialog, showErrorMessage } from '@jupyterlab/apputils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Widget } from '@lumino/widgets';\n/**\n * The class name added to file dialogs.\n */\nconst FILE_DIALOG_CLASS = 'jp-FileDialog';\n/**\n * The class name added to checkboxes in file dialogs.\n */\nconst FILE_DIALOG_CHECKBOX_CLASS = 'jp-FileDialog-Checkbox';\n/**\n * The class name added for the new name label in the rename dialog\n */\nconst RENAME_NEWNAME_TITLE_CLASS = 'jp-new-name-title';\n/**\n * Rename a file with a dialog.\n */\nexport function renameDialog(manager, oldPath, translator) {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    return showDialog({\n        title: trans.__('Rename File'),\n        body: new RenameHandler(oldPath),\n        focusNodeSelector: 'input',\n        buttons: [\n            Dialog.cancelButton({ label: trans.__('Cancel') }),\n            Dialog.okButton({ label: trans.__('Rename') })\n        ]\n    }).then(result => {\n        if (!result.value) {\n            return null;\n        }\n        if (!isValidFileName(result.value)) {\n            void showErrorMessage(trans.__('Rename Error'), Error(trans.__('\"%1\" is not a valid name for a file. Names must have nonzero length, and cannot include \"/\", \"\\\\\", or \":\"', result.value)));\n            return null;\n        }\n        const basePath = PathExt.dirname(oldPath);\n        const newPath = PathExt.join(basePath, result.value);\n        return renameFile(manager, oldPath, newPath);\n    });\n}\n/**\n * Name a file on first save with a dialog.\n */\nexport function nameOnSaveDialog(manager, context, translator) {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    const oldPath = context.path;\n    return showDialog({\n        title: trans.__('Name File'),\n        body: new NameOnSaveHandler(manager, oldPath),\n        focusNodeSelector: 'input',\n        buttons: [Dialog.okButton({ label: trans.__('Enter') })]\n    }).then(result => {\n        context.model.dirty = false;\n        context.contentsModel.renamed = true;\n        if (!result.value) {\n            return renameFile(manager, oldPath, oldPath);\n        }\n        if (!isValidFileName(result.value)) {\n            void showErrorMessage(trans.__('Naming Error'), Error(trans.__('\"%1\" is not a valid name for a file. Names must have nonzero length, and cannot include \"/\", \"\\\\\", or \":\"', result.value)));\n            return renameFile(manager, oldPath, oldPath);\n        }\n        const basePath = PathExt.dirname(oldPath);\n        const newPath = PathExt.join(basePath, result.value);\n        return renameFile(manager, oldPath, newPath);\n    });\n}\n/**\n * Rename a file, asking for confirmation if it is overwriting another.\n */\nexport function renameFile(manager, oldPath, newPath) {\n    return manager.rename(oldPath, newPath).catch(error => {\n        if (error.message.indexOf('409') === -1) {\n            throw error;\n        }\n        return shouldOverwrite(newPath).then(value => {\n            if (value) {\n                return manager.overwrite(oldPath, newPath);\n            }\n            return Promise.reject('File not renamed');\n        });\n    });\n}\n/**\n * Ask the user whether to overwrite a file.\n */\nexport function shouldOverwrite(path, translator) {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    const options = {\n        title: trans.__('Overwrite file?'),\n        body: trans.__('\"%1\" already exists, overwrite?', path),\n        buttons: [\n            Dialog.cancelButton({ label: trans.__('Cancel') }),\n            Dialog.warnButton({ label: trans.__('Overwrite') })\n        ]\n    };\n    return showDialog(options).then(result => {\n        return Promise.resolve(result.button.accept);\n    });\n}\n/**\n * Test whether a name is a valid file name\n *\n * Disallows \"/\", \"\\\", and \":\" in file names, as well as names with zero length.\n */\nexport function isValidFileName(name) {\n    const validNameExp = /[\\/\\\\:]/;\n    return name.length > 0 && !validNameExp.test(name);\n}\n/**\n * A widget used to rename a file.\n */\nclass RenameHandler extends Widget {\n    /**\n     * Construct a new \"rename\" dialog.\n     */\n    constructor(oldPath) {\n        super({ node: Private.createRenameNode(oldPath) });\n        this.addClass(FILE_DIALOG_CLASS);\n        const ext = PathExt.extname(oldPath);\n        const value = (this.inputNode.value = PathExt.basename(oldPath));\n        this.inputNode.setSelectionRange(0, value.length - ext.length);\n    }\n    /**\n     * Get the input text node.\n     */\n    get inputNode() {\n        return this.node.getElementsByTagName('input')[0];\n    }\n    /**\n     * Get the value of the widget.\n     */\n    getValue() {\n        return this.inputNode.value;\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Create the node for a rename handler.\n     */\n    function createRenameNode(oldPath, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        const body = document.createElement('div');\n        const existingLabel = document.createElement('label');\n        existingLabel.textContent = trans.__('File Path');\n        const existingPath = document.createElement('span');\n        existingPath.textContent = oldPath;\n        const nameTitle = document.createElement('label');\n        nameTitle.textContent = trans.__('New Name');\n        nameTitle.className = RENAME_NEWNAME_TITLE_CLASS;\n        const name = document.createElement('input');\n        body.appendChild(existingLabel);\n        body.appendChild(existingPath);\n        body.appendChild(nameTitle);\n        body.appendChild(name);\n        return body;\n    }\n    Private.createRenameNode = createRenameNode;\n})(Private || (Private = {}));\n/**\n * A widget used to name file on first save.\n */\nclass NameOnSaveHandler extends Widget {\n    /**\n     * Construct a new \"name notebook file\" dialog.\n     */\n    constructor(manager, oldPath) {\n        super({ node: Private.createNameFileNode(manager) });\n        this.addClass(FILE_DIALOG_CLASS);\n        const ext = PathExt.extname(oldPath);\n        const value = (this.inputNode.value = PathExt.basename(oldPath));\n        this.inputNode.setSelectionRange(0, value.length - ext.length);\n    }\n    /**\n     * Get the input text node.\n     */\n    get inputNode() {\n        return this.node.getElementsByTagName('input')[0];\n    }\n    /**\n     * Get the value of the input widget.\n     */\n    getValue() {\n        return this.inputNode.value;\n    }\n    /**\n     * Get the checkbox node.\n     */\n    get checkboxNode() {\n        return this.node.getElementsByTagName('input')[1];\n    }\n    /**\n     * Get checked of the checkbox widget.\n     */\n    getChecked() {\n        return this.checkboxNode.checked;\n    }\n}\n/**\n * A namespace for private data.\n */\n(function (Private) {\n    /**\n     * Create the node for a rename after launch handler.\n     */\n    function createNameFileNode(manager, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        const body = document.createElement('div');\n        const name = document.createElement('input');\n        const checkbox = document.createElement('input');\n        const label = document.createElement('label');\n        const div = document.createElement('div');\n        checkbox.type = 'checkbox';\n        checkbox.classList.add(FILE_DIALOG_CHECKBOX_CLASS);\n        checkbox.addEventListener('change', function () {\n            manager.nameFileOnSave = !this.checked;\n        });\n        label.textContent = trans.__(\"Don't ask me again\");\n        body.appendChild(name);\n        div.appendChild(checkbox);\n        div.appendChild(label);\n        body.appendChild(div);\n        return body;\n    }\n    Private.createNameFileNode = createNameFileNode;\n})(Private || (Private = {}));\n//# sourceMappingURL=dialogs.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The document registry token.\n */\nexport const IDocumentManager = new Token('@jupyterlab/docmanager:IDocumentManager');\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Signal } from '@lumino/signaling';\n/**\n * A class that manages the auto saving of a document.\n *\n * #### Notes\n * Implements https://github.com/ipython/ipython/wiki/IPEP-15:-Autosaving-the-IPython-Notebook.\n */\nexport class SaveHandler {\n    /**\n     * Construct a new save handler.\n     */\n    constructor(options) {\n        this._autosaveTimer = -1;\n        this._minInterval = -1;\n        this._interval = -1;\n        this._isActive = false;\n        this._inDialog = false;\n        this._isDisposed = false;\n        this._multiplier = 10;\n        this._context = options.context;\n        const interval = options.saveInterval || 120;\n        this._minInterval = interval * 1000;\n        this._interval = this._minInterval;\n        // Restart the timer when the contents model is updated.\n        this._context.fileChanged.connect(this._setTimer, this);\n        this._context.disposed.connect(this.dispose, this);\n    }\n    /**\n     * The save interval used by the timer (in seconds).\n     */\n    get saveInterval() {\n        return this._interval / 1000;\n    }\n    set saveInterval(value) {\n        this._minInterval = this._interval = value * 1000;\n        if (this._isActive) {\n            this._setTimer();\n        }\n    }\n    /**\n     * Get whether the handler is active.\n     */\n    get isActive() {\n        return this._isActive;\n    }\n    /**\n     * Get whether the save handler is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the save handler.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        clearTimeout(this._autosaveTimer);\n        Signal.clearData(this);\n    }\n    /**\n     * Start the autosaver.\n     */\n    start() {\n        this._isActive = true;\n        this._setTimer();\n    }\n    /**\n     * Stop the autosaver.\n     */\n    stop() {\n        this._isActive = false;\n        clearTimeout(this._autosaveTimer);\n    }\n    /**\n     * Set the timer.\n     */\n    _setTimer() {\n        clearTimeout(this._autosaveTimer);\n        if (!this._isActive) {\n            return;\n        }\n        this._autosaveTimer = window.setTimeout(() => {\n            this._save();\n        }, this._interval);\n    }\n    /**\n     * Handle an autosave timeout.\n     */\n    _save() {\n        const context = this._context;\n        // Trigger the next update.\n        this._setTimer();\n        if (!context) {\n            return;\n        }\n        // Bail if the model is not dirty or the file is not writable, or the dialog\n        // is already showing.\n        const writable = context.contentsModel && context.contentsModel.writable;\n        if (!writable || !context.model.dirty || this._inDialog) {\n            return;\n        }\n        const start = new Date().getTime();\n        context\n            .save()\n            .then(() => {\n            if (this.isDisposed) {\n                return;\n            }\n            const duration = new Date().getTime() - start;\n            // New save interval: higher of 10x save duration or min interval.\n            this._interval = Math.max(this._multiplier * duration, this._minInterval);\n            // Restart the update to pick up the new interval.\n            this._setTimer();\n        })\n            .catch(err => {\n            // If the user canceled the save, do nothing.\n            // FIXME-TRANS: Is this affected by localization?\n            if (err.message === 'Cancel') {\n                return;\n            }\n            // Otherwise, log the error.\n            console.error('Error in Auto-Save', err.message);\n        });\n    }\n}\n//# sourceMappingURL=savehandler.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ArrayExt, each, map, find, filter, toArray } from '@lumino/algorithm';\nimport { DisposableSet } from '@lumino/disposable';\nimport { MessageLoop } from '@lumino/messaging';\nimport { AttachedProperty } from '@lumino/properties';\nimport { Signal } from '@lumino/signaling';\nimport { Time } from '@jupyterlab/coreutils';\nimport { showDialog, Dialog } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\n/**\n * The class name added to document widgets.\n */\nconst DOCUMENT_CLASS = 'jp-Document';\n/**\n * A class that maintains the lifecycle of file-backed widgets.\n */\nexport class DocumentWidgetManager {\n    /**\n     * Construct a new document widget manager.\n     */\n    constructor(options) {\n        this._activateRequested = new Signal(this);\n        this._isDisposed = false;\n        this._registry = options.registry;\n        this.translator = options.translator || nullTranslator;\n    }\n    /**\n     * A signal emitted when one of the documents is activated.\n     */\n    get activateRequested() {\n        return this._activateRequested;\n    }\n    /**\n     * Test whether the document widget manager is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the widget manager.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.disconnectReceiver(this);\n    }\n    /**\n     * Create a widget for a document and handle its lifecycle.\n     *\n     * @param factory - The widget factory.\n     *\n     * @param context - The document context object.\n     *\n     * @returns A widget created by the factory.\n     *\n     * @throws If the factory is not registered.\n     */\n    createWidget(factory, context) {\n        const widget = factory.createNew(context);\n        this._initializeWidget(widget, factory, context);\n        return widget;\n    }\n    /**\n     * When a new widget is created, we need to hook it up\n     * with some signals, update the widget extensions (for\n     * this kind of widget) in the docregistry, among\n     * other things.\n     */\n    _initializeWidget(widget, factory, context) {\n        Private.factoryProperty.set(widget, factory);\n        // Handle widget extensions.\n        const disposables = new DisposableSet();\n        each(this._registry.widgetExtensions(factory.name), extender => {\n            const disposable = extender.createNew(widget, context);\n            if (disposable) {\n                disposables.add(disposable);\n            }\n        });\n        Private.disposablesProperty.set(widget, disposables);\n        widget.disposed.connect(this._onWidgetDisposed, this);\n        this.adoptWidget(context, widget);\n        context.fileChanged.connect(this._onFileChanged, this);\n        context.pathChanged.connect(this._onPathChanged, this);\n        void context.ready.then(() => {\n            void this.setCaption(widget);\n        });\n    }\n    /**\n     * Install the message hook for the widget and add to list\n     * of known widgets.\n     *\n     * @param context - The document context object.\n     *\n     * @param widget - The widget to adopt.\n     */\n    adoptWidget(context, widget) {\n        const widgets = Private.widgetsProperty.get(context);\n        widgets.push(widget);\n        MessageLoop.installMessageHook(widget, this);\n        widget.addClass(DOCUMENT_CLASS);\n        widget.title.closable = true;\n        widget.disposed.connect(this._widgetDisposed, this);\n        Private.contextProperty.set(widget, context);\n    }\n    /**\n     * See if a widget already exists for the given context and widget name.\n     *\n     * @param context - The document context object.\n     *\n     * @returns The found widget, or `undefined`.\n     *\n     * #### Notes\n     * This can be used to use an existing widget instead of opening\n     * a new widget.\n     */\n    findWidget(context, widgetName) {\n        const widgets = Private.widgetsProperty.get(context);\n        if (!widgets) {\n            return undefined;\n        }\n        return find(widgets, widget => {\n            const factory = Private.factoryProperty.get(widget);\n            if (!factory) {\n                return false;\n            }\n            return factory.name === widgetName;\n        });\n    }\n    /**\n     * Get the document context for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The context associated with the widget, or `undefined`.\n     */\n    contextForWidget(widget) {\n        return Private.contextProperty.get(widget);\n    }\n    /**\n     * Clone a widget.\n     *\n     * @param widget - The source widget.\n     *\n     * @returns A new widget or `undefined`.\n     *\n     * #### Notes\n     *  Uses the same widget factory and context as the source, or throws\n     *  if the source widget is not managed by this manager.\n     */\n    cloneWidget(widget) {\n        const context = Private.contextProperty.get(widget);\n        if (!context) {\n            return undefined;\n        }\n        const factory = Private.factoryProperty.get(widget);\n        if (!factory) {\n            return undefined;\n        }\n        const newWidget = factory.createNew(context, widget);\n        this._initializeWidget(newWidget, factory, context);\n        return newWidget;\n    }\n    /**\n     * Close the widgets associated with a given context.\n     *\n     * @param context - The document context object.\n     */\n    closeWidgets(context) {\n        const widgets = Private.widgetsProperty.get(context);\n        return Promise.all(toArray(map(widgets, widget => this.onClose(widget)))).then(() => undefined);\n    }\n    /**\n     * Dispose of the widgets associated with a given context\n     * regardless of the widget's dirty state.\n     *\n     * @param context - The document context object.\n     */\n    deleteWidgets(context) {\n        const widgets = Private.widgetsProperty.get(context);\n        return Promise.all(toArray(map(widgets, widget => this.onDelete(widget)))).then(() => undefined);\n    }\n    /**\n     * Filter a message sent to a message handler.\n     *\n     * @param handler - The target handler of the message.\n     *\n     * @param msg - The message dispatched to the handler.\n     *\n     * @returns `false` if the message should be filtered, of `true`\n     *   if the message should be dispatched to the handler as normal.\n     */\n    messageHook(handler, msg) {\n        switch (msg.type) {\n            case 'close-request':\n                void this.onClose(handler);\n                return false;\n            case 'activate-request': {\n                const context = this.contextForWidget(handler);\n                if (context) {\n                    this._activateRequested.emit(context.path);\n                }\n                break;\n            }\n            default:\n                break;\n        }\n        return true;\n    }\n    /**\n     * Set the caption for widget title.\n     *\n     * @param widget - The target widget.\n     */\n    async setCaption(widget) {\n        const trans = this.translator.load('jupyterlab');\n        const context = Private.contextProperty.get(widget);\n        if (!context) {\n            return;\n        }\n        const model = context.contentsModel;\n        if (!model) {\n            widget.title.caption = '';\n            return;\n        }\n        return context\n            .listCheckpoints()\n            .then((checkpoints) => {\n            if (widget.isDisposed) {\n                return;\n            }\n            const last = checkpoints[checkpoints.length - 1];\n            const checkpoint = last ? Time.format(last.last_modified) : 'None';\n            let caption = trans.__('Name: %1\\nPath: %2\\n', model.name, model.path);\n            if (context.model.readOnly) {\n                caption += trans.__('Read-only');\n            }\n            else {\n                caption +=\n                    trans.__('Last Saved: %1\\n', Time.format(model.last_modified)) +\n                        trans.__('Last Checkpoint: %1', checkpoint);\n            }\n            widget.title.caption = caption;\n        });\n    }\n    /**\n     * Handle `'close-request'` messages.\n     *\n     * @param widget - The target widget.\n     *\n     * @returns A promise that resolves with whether the widget was closed.\n     */\n    async onClose(widget) {\n        var _a;\n        // Handle dirty state.\n        const [shouldClose, ignoreSave] = await this._maybeClose(widget, this.translator);\n        if (widget.isDisposed) {\n            return true;\n        }\n        if (shouldClose) {\n            if (!ignoreSave) {\n                const context = Private.contextProperty.get(widget);\n                if (!context) {\n                    return true;\n                }\n                if ((_a = context.contentsModel) === null || _a === void 0 ? void 0 : _a.writable) {\n                    await context.save(true);\n                }\n                else {\n                    await context.saveAs();\n                }\n            }\n            if (widget.isDisposed) {\n                return true;\n            }\n            widget.dispose();\n        }\n        return shouldClose;\n    }\n    /**\n     * Dispose of widget regardless of widget's dirty state.\n     *\n     * @param widget - The target widget.\n     */\n    onDelete(widget) {\n        widget.dispose();\n        return Promise.resolve(void 0);\n    }\n    /**\n     * Ask the user whether to close an unsaved file.\n     */\n    _maybeClose(widget, translator) {\n        var _a;\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        // Bail if the model is not dirty or other widgets are using the model.)\n        const context = Private.contextProperty.get(widget);\n        if (!context) {\n            return Promise.resolve([true, true]);\n        }\n        let widgets = Private.widgetsProperty.get(context);\n        if (!widgets) {\n            return Promise.resolve([true, true]);\n        }\n        // Filter by whether the factories are read only.\n        widgets = toArray(filter(widgets, widget => {\n            const factory = Private.factoryProperty.get(widget);\n            if (!factory) {\n                return false;\n            }\n            return factory.readOnly === false;\n        }));\n        const factory = Private.factoryProperty.get(widget);\n        if (!factory) {\n            return Promise.resolve([true, true]);\n        }\n        const model = context.model;\n        if (!model.dirty || widgets.length > 1 || factory.readOnly) {\n            return Promise.resolve([true, true]);\n        }\n        const fileName = widget.title.label;\n        const saveLabel = ((_a = context.contentsModel) === null || _a === void 0 ? void 0 : _a.writable) ? trans.__('Save')\n            : trans.__('Save as');\n        return showDialog({\n            title: trans.__('Save your work'),\n            body: trans.__('Save changes in \"%1\" before closing?', fileName),\n            buttons: [\n                Dialog.cancelButton({ label: trans.__('Cancel') }),\n                Dialog.warnButton({ label: trans.__('Discard') }),\n                Dialog.okButton({ label: saveLabel })\n            ]\n        }).then(result => {\n            return [result.button.accept, result.button.displayType === 'warn'];\n        });\n    }\n    /**\n     * Handle the disposal of a widget.\n     */\n    _widgetDisposed(widget) {\n        const context = Private.contextProperty.get(widget);\n        if (!context) {\n            return;\n        }\n        const widgets = Private.widgetsProperty.get(context);\n        if (!widgets) {\n            return;\n        }\n        // Remove the widget.\n        ArrayExt.removeFirstOf(widgets, widget);\n        // Dispose of the context if this is the last widget using it.\n        if (!widgets.length) {\n            context.dispose();\n        }\n    }\n    /**\n     * Handle the disposal of a widget.\n     */\n    _onWidgetDisposed(widget) {\n        const disposables = Private.disposablesProperty.get(widget);\n        disposables.dispose();\n    }\n    /**\n     * Handle a file changed signal for a context.\n     */\n    _onFileChanged(context) {\n        const widgets = Private.widgetsProperty.get(context);\n        each(widgets, widget => {\n            void this.setCaption(widget);\n        });\n    }\n    /**\n     * Handle a path changed signal for a context.\n     */\n    _onPathChanged(context) {\n        const widgets = Private.widgetsProperty.get(context);\n        each(widgets, widget => {\n            void this.setCaption(widget);\n        });\n    }\n}\n/**\n * A private namespace for DocumentManager data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A private attached property for a widget context.\n     */\n    Private.contextProperty = new AttachedProperty({\n        name: 'context',\n        create: () => undefined\n    });\n    /**\n     * A private attached property for a widget factory.\n     */\n    Private.factoryProperty = new AttachedProperty({\n        name: 'factory',\n        create: () => undefined\n    });\n    /**\n     * A private attached property for the widgets associated with a context.\n     */\n    Private.widgetsProperty = new AttachedProperty({\n        name: 'widgets',\n        create: () => []\n    });\n    /**\n     * A private attached property for a widget's disposables.\n     */\n    Private.disposablesProperty = new AttachedProperty({\n        name: 'disposables',\n        create: () => new DisposableSet()\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=widgetmanager.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { sessionContextDialogs } from '@jupyterlab/apputils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { Context } from '@jupyterlab/docregistry';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { ArrayExt, find } from '@lumino/algorithm';\nimport { UUID } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\nimport { Signal } from '@lumino/signaling';\nimport { SaveHandler } from './savehandler';\nimport { DocumentWidgetManager } from './widgetmanager';\n/**\n * The document manager.\n *\n * #### Notes\n * The document manager is used to register model and widget creators,\n * and the file browser uses the document manager to create widgets. The\n * document manager maintains a context for each path and model type that is\n * open, and a list of widgets for each context. The document manager is in\n * control of the proper closing and disposal of the widgets and contexts.\n */\nexport class DocumentManager {\n    /**\n     * Construct a new document manager.\n     */\n    constructor(options) {\n        this._activateRequested = new Signal(this);\n        this._contexts = [];\n        this._isDisposed = false;\n        this._autosave = true;\n        this._nameFileOnSave = true;\n        this._optionChanged = new Signal(this);\n        this._autosaveInterval = 120;\n        this.translator = options.translator || nullTranslator;\n        this.registry = options.registry;\n        this.services = options.manager;\n        this._collaborative = !!options.collaborative;\n        this._dialogs = options.sessionDialogs || sessionContextDialogs;\n        this._docProviderFactory = options.docProviderFactory;\n        this._opener = options.opener;\n        this._when = options.when || options.manager.ready;\n        const widgetManager = new DocumentWidgetManager({\n            registry: this.registry,\n            translator: this.translator\n        });\n        widgetManager.activateRequested.connect(this._onActivateRequested, this);\n        this._widgetManager = widgetManager;\n        this._setBusy = options.setBusy;\n    }\n    /**\n     * A signal emitted when one of the documents is activated.\n     */\n    get activateRequested() {\n        return this._activateRequested;\n    }\n    /**\n     * Whether to autosave documents.\n     */\n    get autosave() {\n        return this._autosave;\n    }\n    set autosave(value) {\n        this._autosave = value;\n        // For each existing context, start/stop the autosave handler as needed.\n        this._contexts.forEach(context => {\n            const handler = Private.saveHandlerProperty.get(context);\n            if (!handler) {\n                return;\n            }\n            if (value === true && !handler.isActive) {\n                handler.start();\n            }\n            else if (value === false && handler.isActive) {\n                handler.stop();\n            }\n        });\n    }\n    /**\n     * Determines the time interval for autosave in seconds.\n     */\n    get autosaveInterval() {\n        return this._autosaveInterval;\n    }\n    set autosaveInterval(value) {\n        this._autosaveInterval = value;\n        // For each existing context, set the save interval as needed.\n        this._contexts.forEach(context => {\n            const handler = Private.saveHandlerProperty.get(context);\n            if (!handler) {\n                return;\n            }\n            handler.saveInterval = value || 120;\n        });\n    }\n    /**\n     * Whether to prompt to name file on first save.\n     */\n    get nameFileOnSave() {\n        return this._nameFileOnSave;\n    }\n    set nameFileOnSave(value) {\n        if (this._nameFileOnSave != value) {\n            this._optionChanged.emit({ nameFileOnSave: value });\n        }\n        this._nameFileOnSave = value;\n    }\n    /**\n     * A signal emitted when option is changed.\n     */\n    get optionChanged() {\n        return this._optionChanged;\n    }\n    /**\n     * Get whether the document manager has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the document manager.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        // Clear any listeners for our signals.\n        Signal.clearData(this);\n        // Close all the widgets for our contexts and dispose the widget manager.\n        this._contexts.forEach(context => {\n            return this._widgetManager.closeWidgets(context);\n        });\n        this._widgetManager.dispose();\n        // Clear the context list.\n        this._contexts.length = 0;\n    }\n    /**\n     * Clone a widget.\n     *\n     * @param widget - The source widget.\n     *\n     * @returns A new widget or `undefined`.\n     *\n     * #### Notes\n     *  Uses the same widget factory and context as the source, or returns\n     *  `undefined` if the source widget is not managed by this manager.\n     */\n    cloneWidget(widget) {\n        return this._widgetManager.cloneWidget(widget);\n    }\n    /**\n     * Close all of the open documents.\n     *\n     * @returns A promise resolving when the widgets are closed.\n     */\n    closeAll() {\n        return Promise.all(this._contexts.map(context => this._widgetManager.closeWidgets(context))).then(() => undefined);\n    }\n    /**\n     * Close the widgets associated with a given path.\n     *\n     * @param path - The target path.\n     *\n     * @returns A promise resolving when the widgets are closed.\n     */\n    closeFile(path) {\n        const close = this._contextsForPath(path).map(c => this._widgetManager.closeWidgets(c));\n        return Promise.all(close).then(x => undefined);\n    }\n    /**\n     * Get the document context for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The context associated with the widget, or `undefined` if no such\n     * context exists.\n     */\n    contextForWidget(widget) {\n        return this._widgetManager.contextForWidget(widget);\n    }\n    /**\n     * Copy a file.\n     *\n     * @param fromFile - The full path of the original file.\n     *\n     * @param toDir - The full path to the target directory.\n     *\n     * @returns A promise which resolves to the contents of the file.\n     */\n    copy(fromFile, toDir) {\n        return this.services.contents.copy(fromFile, toDir);\n    }\n    /**\n     * Create a new file and return the widget used to view it.\n     *\n     * @param path - The file path to create.\n     *\n     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n     *\n     * @param kernel - An optional kernel name/id to override the default.\n     *\n     * @returns The created widget, or `undefined`.\n     *\n     * #### Notes\n     * This function will return `undefined` if a valid widget factory\n     * cannot be found.\n     */\n    createNew(path, widgetName = 'default', kernel) {\n        return this._createOrOpenDocument('create', path, widgetName, kernel);\n    }\n    /**\n     * Delete a file.\n     *\n     * @param path - The full path to the file to be deleted.\n     *\n     * @returns A promise which resolves when the file is deleted.\n     *\n     * #### Notes\n     * If there is a running session associated with the file and no other\n     * sessions are using the kernel, the session will be shut down.\n     */\n    deleteFile(path) {\n        return this.services.sessions\n            .stopIfNeeded(path)\n            .then(() => {\n            return this.services.contents.delete(path);\n        })\n            .then(() => {\n            this._contextsForPath(path).forEach(context => this._widgetManager.deleteWidgets(context));\n            return Promise.resolve(void 0);\n        });\n    }\n    /**\n     * See if a widget already exists for the given path and widget name.\n     *\n     * @param path - The file path to use.\n     *\n     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n     *\n     * @returns The found widget, or `undefined`.\n     *\n     * #### Notes\n     * This can be used to find an existing widget instead of opening\n     * a new widget.\n     */\n    findWidget(path, widgetName = 'default') {\n        const newPath = PathExt.normalize(path);\n        let widgetNames = [widgetName];\n        if (widgetName === 'default') {\n            const factory = this.registry.defaultWidgetFactory(newPath);\n            if (!factory) {\n                return undefined;\n            }\n            widgetNames = [factory.name];\n        }\n        else if (widgetName === null) {\n            widgetNames = this.registry\n                .preferredWidgetFactories(newPath)\n                .map(f => f.name);\n        }\n        for (const context of this._contextsForPath(newPath)) {\n            for (const widgetName of widgetNames) {\n                if (widgetName !== null) {\n                    const widget = this._widgetManager.findWidget(context, widgetName);\n                    if (widget) {\n                        return widget;\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Create a new untitled file.\n     *\n     * @param options - The file content creation options.\n     */\n    newUntitled(options) {\n        if (options.type === 'file') {\n            options.ext = options.ext || '.txt';\n        }\n        return this.services.contents.newUntitled(options);\n    }\n    /**\n     * Open a file and return the widget used to view it.\n     *\n     * @param path - The file path to open.\n     *\n     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n     *\n     * @param kernel - An optional kernel name/id to override the default.\n     *\n     * @returns The created widget, or `undefined`.\n     *\n     * #### Notes\n     * This function will return `undefined` if a valid widget factory\n     * cannot be found.\n     */\n    open(path, widgetName = 'default', kernel, options) {\n        return this._createOrOpenDocument('open', path, widgetName, kernel, options);\n    }\n    /**\n     * Open a file and return the widget used to view it.\n     * Reveals an already existing editor.\n     *\n     * @param path - The file path to open.\n     *\n     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n     *\n     * @param kernel - An optional kernel name/id to override the default.\n     *\n     * @returns The created widget, or `undefined`.\n     *\n     * #### Notes\n     * This function will return `undefined` if a valid widget factory\n     * cannot be found.\n     */\n    openOrReveal(path, widgetName = 'default', kernel, options) {\n        const widget = this.findWidget(path, widgetName);\n        if (widget) {\n            this._opener.open(widget, options || {});\n            return widget;\n        }\n        return this.open(path, widgetName, kernel, options || {});\n    }\n    /**\n     * Overwrite a file.\n     *\n     * @param oldPath - The full path to the original file.\n     *\n     * @param newPath - The full path to the new file.\n     *\n     * @returns A promise containing the new file contents model.\n     */\n    overwrite(oldPath, newPath) {\n        // Cleanly overwrite the file by moving it, making sure the original does\n        // not exist, and then renaming to the new path.\n        const tempPath = `${newPath}.${UUID.uuid4()}`;\n        const cb = () => this.rename(tempPath, newPath);\n        return this.rename(oldPath, tempPath)\n            .then(() => {\n            return this.deleteFile(newPath);\n        })\n            .then(cb, cb);\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldPath - The full path to the original file.\n     *\n     * @param newPath - The full path to the new file.\n     *\n     * @returns A promise containing the new file contents model.  The promise\n     * will reject if the newPath already exists.  Use [[overwrite]] to overwrite\n     * a file.\n     */\n    rename(oldPath, newPath) {\n        return this.services.contents.rename(oldPath, newPath).then(model => {\n            if (model.type == 'notebook' || model.type == 'file') {\n                model.renamed = true;\n            }\n        });\n    }\n    /**\n     * Find a context for a given path and factory name.\n     */\n    _findContext(path, factoryName) {\n        const normalizedPath = this.services.contents.normalize(path);\n        return find(this._contexts, context => {\n            return (context.path === normalizedPath && context.factoryName === factoryName);\n        });\n    }\n    /**\n     * Get the contexts for a given path.\n     *\n     * #### Notes\n     * There may be more than one context for a given path if the path is open\n     * with multiple model factories (for example, a notebook can be open with a\n     * notebook model factory and a text model factory).\n     */\n    _contextsForPath(path) {\n        const normalizedPath = this.services.contents.normalize(path);\n        return this._contexts.filter(context => context.path === normalizedPath);\n    }\n    /**\n     * Create a context from a path and a model factory.\n     */\n    _createContext(path, factory, kernelPreference) {\n        // TODO: Make it impossible to open two different contexts for the same\n        // path. Or at least prompt the closing of all widgets associated with the\n        // old context before opening the new context. This will make things much\n        // more consistent for the users, at the cost of some confusion about what\n        // models are and why sometimes they cannot open the same file in different\n        // widgets that have different models.\n        // Allow options to be passed when adding a sibling.\n        const adopter = (widget, options) => {\n            this._widgetManager.adoptWidget(context, widget);\n            this._opener.open(widget, options);\n        };\n        const modelDBFactory = this.services.contents.getModelDBFactory(path) || undefined;\n        const context = new Context({\n            opener: adopter,\n            manager: this.services,\n            factory,\n            path,\n            kernelPreference,\n            modelDBFactory,\n            setBusy: this._setBusy,\n            sessionDialogs: this._dialogs,\n            collaborative: this._collaborative,\n            docProviderFactory: this._docProviderFactory\n        });\n        const handler = new SaveHandler({\n            context,\n            saveInterval: this.autosaveInterval\n        });\n        Private.saveHandlerProperty.set(context, handler);\n        void context.ready.then(() => {\n            if (this.autosave) {\n                handler.start();\n            }\n        });\n        context.disposed.connect(this._onContextDisposed, this);\n        this._contexts.push(context);\n        return context;\n    }\n    /**\n     * Handle a context disposal.\n     */\n    _onContextDisposed(context) {\n        ArrayExt.removeFirstOf(this._contexts, context);\n    }\n    /**\n     * Get the widget factory for a given widget name.\n     */\n    _widgetFactoryFor(path, widgetName) {\n        const { registry } = this;\n        if (widgetName === 'default') {\n            const factory = registry.defaultWidgetFactory(path);\n            if (!factory) {\n                return undefined;\n            }\n            widgetName = factory.name;\n        }\n        return registry.getWidgetFactory(widgetName);\n    }\n    /**\n     * Creates a new document, or loads one from disk, depending on the `which` argument.\n     * If `which==='create'`, then it creates a new document. If `which==='open'`,\n     * then it loads the document from disk.\n     *\n     * The two cases differ in how the document context is handled, but the creation\n     * of the widget and launching of the kernel are identical.\n     */\n    _createOrOpenDocument(which, path, widgetName = 'default', kernel, options) {\n        const widgetFactory = this._widgetFactoryFor(path, widgetName);\n        if (!widgetFactory) {\n            return undefined;\n        }\n        const modelName = widgetFactory.modelName || 'text';\n        const factory = this.registry.getModelFactory(modelName);\n        if (!factory) {\n            return undefined;\n        }\n        // Handle the kernel pereference.\n        const preference = this.registry.getKernelPreference(path, widgetFactory.name, kernel);\n        let context;\n        let ready = Promise.resolve(undefined);\n        // Handle the load-from-disk case\n        if (which === 'open') {\n            // Use an existing context if available.\n            context = this._findContext(path, factory.name) || null;\n            if (!context) {\n                context = this._createContext(path, factory, preference);\n                // Populate the model, either from disk or a\n                // model backend.\n                ready = this._when.then(() => context.initialize(false));\n            }\n        }\n        else if (which === 'create') {\n            context = this._createContext(path, factory, preference);\n            // Immediately save the contents to disk.\n            ready = this._when.then(() => context.initialize(true));\n        }\n        else {\n            throw new Error(`Invalid argument 'which': ${which}`);\n        }\n        const widget = this._widgetManager.createWidget(widgetFactory, context);\n        this._opener.open(widget, options || {});\n        // If the initial opening of the context fails, dispose of the widget.\n        ready.catch(err => {\n            widget.close();\n        });\n        return widget;\n    }\n    /**\n     * Handle an activateRequested signal from the widget manager.\n     */\n    _onActivateRequested(sender, args) {\n        this._activateRequested.emit(args);\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for a context save handler.\n     */\n    Private.saveHandlerProperty = new AttachedProperty({\n        name: 'saveHandler',\n        create: () => undefined\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=manager.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport React from 'react';\nimport { VDomModel, VDomRenderer } from '@jupyterlab/apputils';\nimport { TextItem } from '@jupyterlab/statusbar';\nimport { nullTranslator } from '@jupyterlab/translation';\n/**\n * A pure functional component for a Saving status item.\n *\n * @param props - the props for the component.\n *\n * @returns a tsx component for rendering the saving state.\n */\nfunction SavingStatusComponent(props) {\n    const translator = props.translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    return React.createElement(TextItem, { source: trans.__('Saving %1', props.fileStatus) });\n}\n/**\n * The amount of time (in ms) to retain the saving completed message\n * before hiding the status item.\n */\nconst SAVING_COMPLETE_MESSAGE_MILLIS = 2000;\n/**\n * A VDomRenderer for a saving status item.\n */\nexport class SavingStatus extends VDomRenderer {\n    /**\n     * Create a new SavingStatus item.\n     */\n    constructor(opts) {\n        super(new SavingStatus.Model(opts.docManager));\n        this.translator = opts.translator || nullTranslator;\n    }\n    /**\n     * Render the SavingStatus item.\n     */\n    render() {\n        if (this.model === null || this.model.status === null) {\n            return null;\n        }\n        else {\n            return (React.createElement(SavingStatusComponent, { fileStatus: this.model.status, translator: this.translator }));\n        }\n    }\n}\n/**\n * A namespace for SavingStatus statics.\n */\n(function (SavingStatus) {\n    /**\n     * A VDomModel for the SavingStatus item.\n     */\n    class Model extends VDomModel {\n        /**\n         * Create a new SavingStatus model.\n         */\n        constructor(docManager) {\n            super();\n            /**\n             * React to a saving status change from the current document widget.\n             */\n            this._onStatusChange = (_documentModel, newStatus) => {\n                this._status = newStatus;\n                if (this._status === 'completed') {\n                    setTimeout(() => {\n                        this._status = null;\n                        this.stateChanged.emit(void 0);\n                    }, SAVING_COMPLETE_MESSAGE_MILLIS);\n                    this.stateChanged.emit(void 0);\n                }\n                else {\n                    this.stateChanged.emit(void 0);\n                }\n            };\n            this._status = null;\n            this._widget = null;\n            this._status = null;\n            this.widget = null;\n            this._docManager = docManager;\n        }\n        /**\n         * The current status of the model.\n         */\n        get status() {\n            return this._status;\n        }\n        /**\n         * The current widget for the model. Any widget can be assigned,\n         * but it only has any effect if the widget is an IDocument widget\n         * known to the application document manager.\n         */\n        get widget() {\n            return this._widget;\n        }\n        set widget(widget) {\n            const oldWidget = this._widget;\n            if (oldWidget !== null) {\n                const oldContext = this._docManager.contextForWidget(oldWidget);\n                if (oldContext) {\n                    oldContext.saveState.disconnect(this._onStatusChange);\n                }\n            }\n            this._widget = widget;\n            if (this._widget === null) {\n                this._status = null;\n            }\n            else {\n                const widgetContext = this._docManager.contextForWidget(this._widget);\n                if (widgetContext) {\n                    widgetContext.saveState.connect(this._onStatusChange);\n                }\n            }\n        }\n    }\n    SavingStatus.Model = Model;\n})(SavingStatus || (SavingStatus = {}));\n//# sourceMappingURL=savingstatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport React from 'react';\nimport { VDomModel, VDomRenderer } from '@jupyterlab/apputils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { TextItem } from '@jupyterlab/statusbar';\n/**\n * A pure component for rendering a file path (or activity name).\n *\n * @param props - the props for the component.\n *\n * @returns a tsx component for a file path.\n */\nfunction PathStatusComponent(props) {\n    return React.createElement(TextItem, { source: props.name, title: props.fullPath });\n}\n/**\n * A status bar item for the current file path (or activity name).\n */\nexport class PathStatus extends VDomRenderer {\n    /**\n     * Construct a new PathStatus status item.\n     */\n    constructor(opts) {\n        super(new PathStatus.Model(opts.docManager));\n        this.node.title = this.model.path;\n    }\n    /**\n     * Render the status item.\n     */\n    render() {\n        return (React.createElement(PathStatusComponent, { fullPath: this.model.path, name: this.model.name }));\n    }\n}\n/**\n * A namespace for PathStatus statics.\n */\n(function (PathStatus) {\n    /**\n     * A VDomModel for rendering the PathStatus status item.\n     */\n    class Model extends VDomModel {\n        /**\n         * Construct a new model.\n         *\n         * @param docManager: the application document manager. Used to check\n         *   whether the current widget is a document.\n         */\n        constructor(docManager) {\n            super();\n            /**\n             * React to a title change for the current widget.\n             */\n            this._onTitleChange = (title) => {\n                const oldState = this._getAllState();\n                this._name = title.label;\n                this._triggerChange(oldState, this._getAllState());\n            };\n            /**\n             * React to a path change for the current document.\n             */\n            this._onPathChange = (_documentModel, newPath) => {\n                const oldState = this._getAllState();\n                this._path = newPath;\n                this._name = PathExt.basename(newPath);\n                this._triggerChange(oldState, this._getAllState());\n            };\n            this._path = '';\n            this._name = '';\n            this._widget = null;\n            this._docManager = docManager;\n        }\n        /**\n         * The current path for the application.\n         */\n        get path() {\n            return this._path;\n        }\n        /**\n         * The name of the current activity.\n         */\n        get name() {\n            return this._name;\n        }\n        /**\n         * The current widget for the application.\n         */\n        get widget() {\n            return this._widget;\n        }\n        set widget(widget) {\n            const oldWidget = this._widget;\n            if (oldWidget !== null) {\n                const oldContext = this._docManager.contextForWidget(oldWidget);\n                if (oldContext) {\n                    oldContext.pathChanged.disconnect(this._onPathChange);\n                }\n                else {\n                    oldWidget.title.changed.disconnect(this._onTitleChange);\n                }\n            }\n            const oldState = this._getAllState();\n            this._widget = widget;\n            if (this._widget === null) {\n                this._path = '';\n                this._name = '';\n            }\n            else {\n                const widgetContext = this._docManager.contextForWidget(this._widget);\n                if (widgetContext) {\n                    this._path = widgetContext.path;\n                    this._name = PathExt.basename(widgetContext.path);\n                    widgetContext.pathChanged.connect(this._onPathChange);\n                }\n                else {\n                    this._path = '';\n                    this._name = this._widget.title.label;\n                    this._widget.title.changed.connect(this._onTitleChange);\n                }\n            }\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * Get the current state of the model.\n         */\n        _getAllState() {\n            return [this._path, this._name];\n        }\n        /**\n         * Trigger a state change to rerender.\n         */\n        _triggerChange(oldState, newState) {\n            if (oldState[0] !== newState[0] || oldState[1] !== newState[1]) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    PathStatus.Model = Model;\n})(PathStatus || (PathStatus = {}));\n//# sourceMappingURL=pathstatus.js.map"],"sourceRoot":""}