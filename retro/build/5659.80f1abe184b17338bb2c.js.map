{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/fileeditor/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/fileeditor/lib/tabspacestatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/fileeditor/lib/widget.js"],"names":["IEditorTracker","Token","TabSpaceComponent","props","trans","translator","nullTranslator","load","description","isSpaces","__","TextItem","onClick","handleClick","source","tabSpace","title","TabSpaceStatus","VDomRenderer","options","super","Model","this","_popup","_menu","menu","addClass","interactiveItem","model","config","insertSpaces","tabSize","_handleClick","dispose","aboutToClose","connect","_menuClosed","showPopup","body","anchor","align","removeClass","clickedItem","VDomModel","arguments","_config","val","oldConfig","_triggerChange","oldValue","newValue","oldSpaces","oldSize","newSpaces","newSize","stateChanged","emit","FileEditorCodeWrapper","CodeEditorWrapper","factory","context","_ready","PromiseDelegate","_context","editor","node","dataset","value","text","toString","ready","then","_onContextReady","modelDB","isCollaborative","connected","collaborators","localCollaborator","uuid","sessionId","selectionStyle","Object","assign","CodeEditor","color","changed","_onCollaboratorsChanged","promise","isDisposed","contextModel","clearHistory","contentChanged","_onContentChanged","resolve","undefined","editorModel","key","selections","keys","has","delete","FileEditor","Widget","_mimeTypeService","mimeTypeService","editorWidget","pathChanged","_onPathChanged","layout","StackedLayout","addWidget","event","type","_ensureFocus","msg","onAfterAttach","addEventListener","removeEventListener","hasFocus","focus","localPath","mimeType","getMimeTypeByFilePath","FileEditorFactory","ABCWidgetFactory","factoryOptions","_services","editorServices","func","factoryService","newDocumentEditor","content","icon","textEditorIcon","widget","DocumentWidget","saveState","sender","state","contentsModel","renamed","name","startsWith","shouldNameFile"],"mappings":"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","file":"5659.80f1abe184b17338bb2c.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The editor tracker token.\n */\nexport const IEditorTracker = new Token('@jupyterlab/fileeditor:IEditorTracker');\n/* tslint:enable */\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport React from 'react';\nimport { VDomRenderer, VDomModel } from '@jupyterlab/apputils';\nimport { interactiveItem, clickedItem, showPopup, TextItem } from '@jupyterlab/statusbar';\nimport { nullTranslator } from '@jupyterlab/translation';\n/**\n * A pure functional component for rendering the TabSpace status.\n */\nfunction TabSpaceComponent(props) {\n    const translator = props.translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    const description = props.isSpaces\n        ? trans.__('Spaces')\n        : trans.__('Tab Size');\n    return (React.createElement(TextItem, { onClick: props.handleClick, source: `${description}: ${props.tabSpace}`, title: trans.__('Change Tab indentationâ€¦') }));\n}\n/**\n * A VDomRenderer for a tabs vs. spaces status item.\n */\nexport class TabSpaceStatus extends VDomRenderer {\n    /**\n     * Create a new tab/space status item.\n     */\n    constructor(options) {\n        super(new TabSpaceStatus.Model());\n        this._popup = null;\n        this._menu = options.menu;\n        this.translator = options.translator || nullTranslator;\n        this.addClass(interactiveItem);\n    }\n    /**\n     * Render the TabSpace status item.\n     */\n    render() {\n        if (!this.model || !this.model.config) {\n            return null;\n        }\n        else {\n            return (React.createElement(TabSpaceComponent, { isSpaces: this.model.config.insertSpaces, tabSpace: this.model.config.tabSize, handleClick: () => this._handleClick(), translator: this.translator }));\n        }\n    }\n    /**\n     * Handle a click on the status item.\n     */\n    _handleClick() {\n        const menu = this._menu;\n        if (this._popup) {\n            this._popup.dispose();\n        }\n        menu.aboutToClose.connect(this._menuClosed, this);\n        this._popup = showPopup({\n            body: menu,\n            anchor: this,\n            align: 'right'\n        });\n    }\n    _menuClosed() {\n        this.removeClass(clickedItem);\n    }\n}\n/**\n * A namespace for TabSpace statics.\n */\n(function (TabSpaceStatus) {\n    /**\n     * A VDomModel for the TabSpace status item.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super(...arguments);\n            this._config = null;\n        }\n        /**\n         * The editor config from the settings system.\n         */\n        get config() {\n            return this._config;\n        }\n        set config(val) {\n            const oldConfig = this._config;\n            this._config = val;\n            this._triggerChange(oldConfig, this._config);\n        }\n        _triggerChange(oldValue, newValue) {\n            const oldSpaces = oldValue && oldValue.insertSpaces;\n            const oldSize = oldValue && oldValue.tabSize;\n            const newSpaces = newValue && newValue.insertSpaces;\n            const newSize = newValue && newValue.tabSize;\n            if (oldSpaces !== newSpaces || oldSize !== newSize) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    TabSpaceStatus.Model = Model;\n})(TabSpaceStatus || (TabSpaceStatus = {}));\n//# sourceMappingURL=tabspacestatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { CodeEditor, CodeEditorWrapper } from '@jupyterlab/codeeditor';\nimport { ABCWidgetFactory, DocumentWidget } from '@jupyterlab/docregistry';\nimport { textEditorIcon } from '@jupyterlab/ui-components';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { StackedLayout, Widget } from '@lumino/widgets';\n/**\n * The data attribute added to a widget that can run code.\n */\nconst CODE_RUNNER = 'jpCodeRunner';\n/**\n * The data attribute added to a widget that can undo.\n */\nconst UNDOER = 'jpUndoer';\n/**\n * A code editor wrapper for the file editor.\n */\nexport class FileEditorCodeWrapper extends CodeEditorWrapper {\n    /**\n     * Construct a new editor widget.\n     */\n    constructor(options) {\n        super({\n            factory: options.factory,\n            model: options.context.model\n        });\n        this._ready = new PromiseDelegate();\n        const context = (this._context = options.context);\n        const editor = this.editor;\n        this.addClass('jp-FileEditorCodeWrapper');\n        this.node.dataset[CODE_RUNNER] = 'true';\n        this.node.dataset[UNDOER] = 'true';\n        editor.model.value.text = context.model.toString();\n        void context.ready.then(() => {\n            this._onContextReady();\n        });\n        if (context.model.modelDB.isCollaborative) {\n            const modelDB = context.model.modelDB;\n            void modelDB.connected.then(() => {\n                const collaborators = modelDB.collaborators;\n                if (!collaborators) {\n                    return;\n                }\n                // Setup the selection style for collaborators\n                const localCollaborator = collaborators.localCollaborator;\n                this.editor.uuid = localCollaborator.sessionId;\n                this.editor.selectionStyle = Object.assign(Object.assign({}, CodeEditor.defaultSelectionStyle), { color: localCollaborator.color });\n                collaborators.changed.connect(this._onCollaboratorsChanged, this);\n                // Trigger an initial onCollaboratorsChanged event.\n                this._onCollaboratorsChanged();\n            });\n        }\n    }\n    /**\n     * Get the context for the editor widget.\n     */\n    get context() {\n        return this._context;\n    }\n    /**\n     * A promise that resolves when the file editor is ready.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * Handle actions that should be taken when the context is ready.\n     */\n    _onContextReady() {\n        if (this.isDisposed) {\n            return;\n        }\n        const contextModel = this._context.model;\n        const editor = this.editor;\n        const editorModel = editor.model;\n        // Set the editor model value.\n        editorModel.value.text = contextModel.toString();\n        // Prevent the initial loading from disk from being in the editor history.\n        editor.clearHistory();\n        // Wire signal connections.\n        contextModel.contentChanged.connect(this._onContentChanged, this);\n        // Resolve the ready promise.\n        this._ready.resolve(undefined);\n    }\n    /**\n     * Handle a change in context model content.\n     */\n    _onContentChanged() {\n        const editorModel = this.editor.model;\n        const oldValue = editorModel.value.text;\n        const newValue = this._context.model.toString();\n        if (oldValue !== newValue) {\n            editorModel.value.text = newValue;\n        }\n    }\n    /**\n     * Handle a change to the collaborators on the model\n     * by updating UI elements associated with them.\n     */\n    _onCollaboratorsChanged() {\n        // If there are selections corresponding to non-collaborators,\n        // they are stale and should be removed.\n        const collaborators = this._context.model.modelDB.collaborators;\n        if (!collaborators) {\n            return;\n        }\n        for (const key of this.editor.model.selections.keys()) {\n            if (!collaborators.has(key)) {\n                this.editor.model.selections.delete(key);\n            }\n        }\n    }\n}\n/**\n * A widget for editors.\n */\nexport class FileEditor extends Widget {\n    /**\n     * Construct a new editor widget.\n     */\n    constructor(options) {\n        super();\n        this.addClass('jp-FileEditor');\n        const context = (this._context = options.context);\n        this._mimeTypeService = options.mimeTypeService;\n        const editorWidget = (this.editorWidget = new FileEditorCodeWrapper(options));\n        this.editor = editorWidget.editor;\n        this.model = editorWidget.model;\n        // Listen for changes to the path.\n        context.pathChanged.connect(this._onPathChanged, this);\n        this._onPathChanged();\n        const layout = (this.layout = new StackedLayout());\n        layout.addWidget(editorWidget);\n    }\n    /**\n     * Get the context for the editor widget.\n     */\n    get context() {\n        return this.editorWidget.context;\n    }\n    /**\n     * A promise that resolves when the file editor is ready.\n     */\n    get ready() {\n        return this.editorWidget.ready;\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the widget's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        if (!this.model) {\n            return;\n        }\n        switch (event.type) {\n            case 'mousedown':\n                this._ensureFocus();\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle `after-attach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        const node = this.node;\n        node.addEventListener('mousedown', this);\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        const node = this.node;\n        node.removeEventListener('mousedown', this);\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        this._ensureFocus();\n    }\n    /**\n     * Ensure that the widget has focus.\n     */\n    _ensureFocus() {\n        if (!this.editor.hasFocus()) {\n            this.editor.focus();\n        }\n    }\n    /**\n     * Handle a change to the path.\n     */\n    _onPathChanged() {\n        const editor = this.editor;\n        const localPath = this._context.localPath;\n        editor.model.mimeType = this._mimeTypeService.getMimeTypeByFilePath(localPath);\n    }\n}\n/**\n * A widget factory for editors.\n */\nexport class FileEditorFactory extends ABCWidgetFactory {\n    /**\n     * Construct a new editor widget factory.\n     */\n    constructor(options) {\n        super(options.factoryOptions);\n        this._services = options.editorServices;\n    }\n    /**\n     * Create a new widget given a context.\n     */\n    createNewWidget(context) {\n        const func = this._services.factoryService.newDocumentEditor;\n        const factory = options => {\n            return func(options);\n        };\n        const content = new FileEditor({\n            factory,\n            context,\n            mimeTypeService: this._services.mimeTypeService\n        });\n        content.title.icon = textEditorIcon;\n        const widget = new DocumentWidget({ content, context });\n        widget.context.saveState.connect((sender, state) => {\n            const model = sender.contentsModel;\n            /* emits shouldNameFile signal\n               when save is completed, file is not renamed and the name starts with 'untitled'\n            */\n            if (state === 'completed-manual' &&\n                model &&\n                !model.renamed == true &&\n                model.name.startsWith('untitled')) {\n                widget.shouldNameFile.emit(undefined);\n            }\n        });\n        return widget;\n    }\n}\n//# sourceMappingURL=widget.js.map"],"sourceRoot":""}