{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/settingregistry/lib/settingregistry.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/settingregistry/lib/tokens.js"],"names":["copy","JSONExt","RECORD_SEPARATOR","String","fromCharCode","DefaultSchemaValidator","this","_composer","useDefaults","_validator","addSchema","plugin","populate","validate","getSchema","id","compose","schema","type","dataPath","keyword","schemaPath","message","_addSchema","validateData","user","raw","error","SyntaxError","column","description","lineNumber","errors","composite","data","composer","validator","validateSchema","removeSchema","SettingRegistry","options","plugins","Object","create","_pluginChanged","Signal","_ready","Promise","resolve","_transformers","connector","_timeout","timeout","_preload","key","undefined","load","then","get","Settings","registry","reload","fetched","fetch","_load","_transform","emit","Private","annotatedPlugin","_save","value","set","assign","transforms","transformers","Error","DisposableDelegate","upload","_validate","output","forEach","index","push","console","warn","join","all","map","async","_a","save","phase","started","Date","getTime","elapsed","transformed","call","setTimeout","_changed","_isDisposed","pluginChanged","connect","_onPluginChanged","version","annotatedDefaults","reifyDefault","remove","sender","reconcileShortcuts","defaults","memo","filter","shortcut","keys","CommandRegistry","selector","s","disabled","concat","indent","nondescript","untitled","body","reduce","acc","val","idx","rows","split","length","trim","indexOf","prefix","source","pre","root","properties","default","result","props","property","title","sort","a","b","localeCompare","Math","max","repeat","reified","spaces","JSON","stringify","str","defaultDocumentedValue","attribute","documentedValue","ISettingRegistry","Token"],"mappings":"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","file":"153.95bd65e4af2d5c46f373.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport Ajv from 'ajv';\nimport * as json5 from 'json5';\nimport { CommandRegistry } from '@lumino/commands';\nimport { JSONExt } from '@lumino/coreutils';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { Signal } from '@lumino/signaling';\nimport SCHEMA from './plugin-schema.json';\n/**\n * An alias for the JSON deep copy function.\n */\nconst copy = JSONExt.deepCopy;\n/**\n * The default number of milliseconds before a `load()` call to the registry\n * will wait before timing out if it requires a transformation that has not been\n * registered.\n */\nconst DEFAULT_TRANSFORM_TIMEOUT = 1000;\n/**\n * The ASCII record separator character.\n */\nconst RECORD_SEPARATOR = String.fromCharCode(30);\n/**\n * The default implementation of a schema validator.\n */\nexport class DefaultSchemaValidator {\n    /**\n     * Instantiate a schema validator.\n     */\n    constructor() {\n        this._composer = new Ajv({ useDefaults: true });\n        this._validator = new Ajv();\n        this._composer.addSchema(SCHEMA, 'jupyterlab-plugin-schema');\n        this._validator.addSchema(SCHEMA, 'jupyterlab-plugin-schema');\n    }\n    /**\n     * Validate a plugin's schema and user data; populate the `composite` data.\n     *\n     * @param plugin - The plugin being validated. Its `composite` data will be\n     * populated by reference.\n     *\n     * @param populate - Whether plugin data should be populated, defaults to\n     * `true`.\n     *\n     * @return A list of errors if either the schema or data fail to validate or\n     * `null` if there are no errors.\n     */\n    validateData(plugin, populate = true) {\n        const validate = this._validator.getSchema(plugin.id);\n        const compose = this._composer.getSchema(plugin.id);\n        // If the schemas do not exist, add them to the validator and continue.\n        if (!validate || !compose) {\n            if (plugin.schema.type !== 'object') {\n                const keyword = 'schema';\n                const message = `Setting registry schemas' root-level type must be ` +\n                    `'object', rejecting type: ${plugin.schema.type}`;\n                return [{ dataPath: 'type', keyword, schemaPath: '', message }];\n            }\n            const errors = this._addSchema(plugin.id, plugin.schema);\n            return errors || this.validateData(plugin);\n        }\n        // Parse the raw commented JSON into a user map.\n        let user;\n        try {\n            user = json5.parse(plugin.raw);\n        }\n        catch (error) {\n            if (error instanceof SyntaxError) {\n                return [\n                    {\n                        dataPath: '',\n                        keyword: 'syntax',\n                        schemaPath: '',\n                        message: error.message\n                    }\n                ];\n            }\n            const { column, description } = error;\n            const line = error.lineNumber;\n            return [\n                {\n                    dataPath: '',\n                    keyword: 'parse',\n                    schemaPath: '',\n                    message: `${description} (line ${line} column ${column})`\n                }\n            ];\n        }\n        if (!validate(user)) {\n            return validate.errors;\n        }\n        // Copy the user data before merging defaults into composite map.\n        const composite = copy(user);\n        if (!compose(composite)) {\n            return compose.errors;\n        }\n        if (populate) {\n            plugin.data = { composite, user };\n        }\n        return null;\n    }\n    /**\n     * Add a schema to the validator.\n     *\n     * @param plugin - The plugin ID.\n     *\n     * @param schema - The schema being added.\n     *\n     * @return A list of errors if the schema fails to validate or `null` if there\n     * are no errors.\n     *\n     * #### Notes\n     * It is safe to call this function multiple times with the same plugin name.\n     */\n    _addSchema(plugin, schema) {\n        const composer = this._composer;\n        const validator = this._validator;\n        const validate = validator.getSchema('jupyterlab-plugin-schema');\n        // Validate against the main schema.\n        if (!validate(schema)) {\n            return validate.errors;\n        }\n        // Validate against the JSON schema meta-schema.\n        if (!validator.validateSchema(schema)) {\n            return validator.errors;\n        }\n        // Remove if schema already exists.\n        composer.removeSchema(plugin);\n        validator.removeSchema(plugin);\n        // Add schema to the validator and composer.\n        composer.addSchema(schema, plugin);\n        validator.addSchema(schema, plugin);\n        return null;\n    }\n}\n/**\n * The default concrete implementation of a setting registry.\n */\nexport class SettingRegistry {\n    /**\n     * Create a new setting registry.\n     */\n    constructor(options) {\n        /**\n         * The schema of the setting registry.\n         */\n        this.schema = SCHEMA;\n        /**\n         * The collection of setting registry plugins.\n         */\n        this.plugins = Object.create(null);\n        this._pluginChanged = new Signal(this);\n        this._ready = Promise.resolve();\n        this._transformers = Object.create(null);\n        this.connector = options.connector;\n        this.validator = options.validator || new DefaultSchemaValidator();\n        this._timeout = options.timeout || DEFAULT_TRANSFORM_TIMEOUT;\n        // Preload with any available data at instantiation-time.\n        if (options.plugins) {\n            this._ready = this._preload(options.plugins);\n        }\n    }\n    /**\n     * A signal that emits the name of a plugin when its settings change.\n     */\n    get pluginChanged() {\n        return this._pluginChanged;\n    }\n    /**\n     * Get an individual setting.\n     *\n     * @param plugin - The name of the plugin whose settings are being retrieved.\n     *\n     * @param key - The name of the setting being retrieved.\n     *\n     * @returns A promise that resolves when the setting is retrieved.\n     */\n    async get(plugin, key) {\n        // Wait for data preload before allowing normal operation.\n        await this._ready;\n        const plugins = this.plugins;\n        if (plugin in plugins) {\n            const { composite, user } = plugins[plugin].data;\n            return {\n                composite: composite[key] !== undefined ? copy(composite[key]) : undefined,\n                user: user[key] !== undefined ? copy(user[key]) : undefined\n            };\n        }\n        return this.load(plugin).then(() => this.get(plugin, key));\n    }\n    /**\n     * Load a plugin's settings into the setting registry.\n     *\n     * @param plugin - The name of the plugin whose settings are being loaded.\n     *\n     * @returns A promise that resolves with a plugin settings object or rejects\n     * if the plugin is not found.\n     */\n    async load(plugin) {\n        // Wait for data preload before allowing normal operation.\n        await this._ready;\n        const plugins = this.plugins;\n        const registry = this; // eslint-disable-line\n        // If the plugin exists, resolve.\n        if (plugin in plugins) {\n            return new Settings({ plugin: plugins[plugin], registry });\n        }\n        // If the plugin needs to be loaded from the data connector, fetch.\n        return this.reload(plugin);\n    }\n    /**\n     * Reload a plugin's settings into the registry even if they already exist.\n     *\n     * @param plugin - The name of the plugin whose settings are being reloaded.\n     *\n     * @returns A promise that resolves with a plugin settings object or rejects\n     * with a list of `ISchemaValidator.IError` objects if it fails.\n     */\n    async reload(plugin) {\n        // Wait for data preload before allowing normal operation.\n        await this._ready;\n        const fetched = await this.connector.fetch(plugin);\n        const plugins = this.plugins; // eslint-disable-line\n        const registry = this; // eslint-disable-line\n        if (fetched === undefined) {\n            throw [\n                {\n                    dataPath: '',\n                    keyword: 'id',\n                    message: `Could not fetch settings for ${plugin}.`,\n                    schemaPath: ''\n                }\n            ];\n        }\n        await this._load(await this._transform('fetch', fetched));\n        this._pluginChanged.emit(plugin);\n        return new Settings({ plugin: plugins[plugin], registry });\n    }\n    /**\n     * Remove a single setting in the registry.\n     *\n     * @param plugin - The name of the plugin whose setting is being removed.\n     *\n     * @param key - The name of the setting being removed.\n     *\n     * @returns A promise that resolves when the setting is removed.\n     */\n    async remove(plugin, key) {\n        // Wait for data preload before allowing normal operation.\n        await this._ready;\n        const plugins = this.plugins;\n        if (!(plugin in plugins)) {\n            return;\n        }\n        const raw = json5.parse(plugins[plugin].raw);\n        // Delete both the value and any associated comment.\n        delete raw[key];\n        delete raw[`// ${key}`];\n        plugins[plugin].raw = Private.annotatedPlugin(plugins[plugin], raw);\n        return this._save(plugin);\n    }\n    /**\n     * Set a single setting in the registry.\n     *\n     * @param plugin - The name of the plugin whose setting is being set.\n     *\n     * @param key - The name of the setting being set.\n     *\n     * @param value - The value of the setting being set.\n     *\n     * @returns A promise that resolves when the setting has been saved.\n     *\n     */\n    async set(plugin, key, value) {\n        // Wait for data preload before allowing normal operation.\n        await this._ready;\n        const plugins = this.plugins;\n        if (!(plugin in plugins)) {\n            return this.load(plugin).then(() => this.set(plugin, key, value));\n        }\n        // Parse the raw JSON string removing all comments and return an object.\n        const raw = json5.parse(plugins[plugin].raw);\n        plugins[plugin].raw = Private.annotatedPlugin(plugins[plugin], Object.assign(Object.assign({}, raw), { [key]: value }));\n        return this._save(plugin);\n    }\n    /**\n     * Register a plugin transform function to act on a specific plugin.\n     *\n     * @param plugin - The name of the plugin whose settings are transformed.\n     *\n     * @param transforms - The transform functions applied to the plugin.\n     *\n     * @returns A disposable that removes the transforms from the registry.\n     *\n     * #### Notes\n     * - `compose` transformations: The registry automatically overwrites a\n     * plugin's default values with user overrides, but a plugin may instead wish\n     * to merge values. This behavior can be accomplished in a `compose`\n     * transformation.\n     * - `fetch` transformations: The registry uses the plugin data that is\n     * fetched from its connector. If a plugin wants to override, e.g. to update\n     * its schema with dynamic defaults, a `fetch` transformation can be applied.\n     */\n    transform(plugin, transforms) {\n        const transformers = this._transformers;\n        if (plugin in transformers) {\n            throw new Error(`${plugin} already has a transformer.`);\n        }\n        transformers[plugin] = {\n            fetch: transforms.fetch || (plugin => plugin),\n            compose: transforms.compose || (plugin => plugin)\n        };\n        return new DisposableDelegate(() => {\n            delete transformers[plugin];\n        });\n    }\n    /**\n     * Upload a plugin's settings.\n     *\n     * @param plugin - The name of the plugin whose settings are being set.\n     *\n     * @param raw - The raw plugin settings being uploaded.\n     *\n     * @returns A promise that resolves when the settings have been saved.\n     */\n    async upload(plugin, raw) {\n        // Wait for data preload before allowing normal operation.\n        await this._ready;\n        const plugins = this.plugins;\n        if (!(plugin in plugins)) {\n            return this.load(plugin).then(() => this.upload(plugin, raw));\n        }\n        // Set the local copy.\n        plugins[plugin].raw = raw;\n        return this._save(plugin);\n    }\n    /**\n     * Load a plugin into the registry.\n     */\n    async _load(data) {\n        const plugin = data.id;\n        // Validate and preload the item.\n        try {\n            await this._validate(data);\n        }\n        catch (errors) {\n            const output = [`Validating ${plugin} failed:`];\n            errors.forEach((error, index) => {\n                const { dataPath, schemaPath, keyword, message } = error;\n                if (dataPath || schemaPath) {\n                    output.push(`${index} - schema @ ${schemaPath}, data @ ${dataPath}`);\n                }\n                output.push(`{${keyword}} ${message}`);\n            });\n            console.warn(output.join('\\n'));\n            throw errors;\n        }\n    }\n    /**\n     * Preload a list of plugins and fail gracefully.\n     */\n    async _preload(plugins) {\n        await Promise.all(plugins.map(async (plugin) => {\n            var _a;\n            try {\n                // Apply a transformation to the plugin if necessary.\n                await this._load(await this._transform('fetch', plugin));\n            }\n            catch (errors) {\n                /* Ignore preload timeout errors silently. */\n                if (((_a = errors[0]) === null || _a === void 0 ? void 0 : _a.keyword) !== 'timeout') {\n                    console.warn('Ignored setting registry preload errors.', errors);\n                }\n            }\n        }));\n    }\n    /**\n     * Save a plugin in the registry.\n     */\n    async _save(plugin) {\n        const plugins = this.plugins;\n        if (!(plugin in plugins)) {\n            throw new Error(`${plugin} does not exist in setting registry.`);\n        }\n        try {\n            await this._validate(plugins[plugin]);\n        }\n        catch (errors) {\n            console.warn(`${plugin} validation errors:`, errors);\n            throw new Error(`${plugin} failed to validate; check console.`);\n        }\n        await this.connector.save(plugin, plugins[plugin].raw);\n        // Fetch and reload the data to guarantee server and client are in sync.\n        const fetched = await this.connector.fetch(plugin);\n        if (fetched === undefined) {\n            throw [\n                {\n                    dataPath: '',\n                    keyword: 'id',\n                    message: `Could not fetch settings for ${plugin}.`,\n                    schemaPath: ''\n                }\n            ];\n        }\n        await this._load(await this._transform('fetch', fetched));\n        this._pluginChanged.emit(plugin);\n    }\n    /**\n     * Transform the plugin if necessary.\n     */\n    async _transform(phase, plugin, started = new Date().getTime()) {\n        const elapsed = new Date().getTime() - started;\n        const id = plugin.id;\n        const transformers = this._transformers;\n        const timeout = this._timeout;\n        if (!plugin.schema['jupyter.lab.transform']) {\n            return plugin;\n        }\n        if (id in transformers) {\n            const transformed = transformers[id][phase].call(null, plugin);\n            if (transformed.id !== id) {\n                throw [\n                    {\n                        dataPath: '',\n                        keyword: 'id',\n                        message: 'Plugin transformations cannot change plugin IDs.',\n                        schemaPath: ''\n                    }\n                ];\n            }\n            return transformed;\n        }\n        // If the timeout has not been exceeded, stall and try again in 250ms.\n        if (elapsed < timeout) {\n            await new Promise(resolve => {\n                setTimeout(() => {\n                    resolve();\n                }, 250);\n            });\n            return this._transform(phase, plugin, started);\n        }\n        throw [\n            {\n                dataPath: '',\n                keyword: 'timeout',\n                message: `Transforming ${plugin.id} timed out.`,\n                schemaPath: ''\n            }\n        ];\n    }\n    /**\n     * Validate and preload a plugin, compose the `composite` data.\n     */\n    async _validate(plugin) {\n        // Validate the user data and create the composite data.\n        const errors = this.validator.validateData(plugin);\n        if (errors) {\n            throw errors;\n        }\n        // Apply a transformation if necessary and set the local copy.\n        this.plugins[plugin.id] = await this._transform('compose', plugin);\n    }\n}\n/**\n * A manager for a specific plugin's settings.\n */\nexport class Settings {\n    /**\n     * Instantiate a new plugin settings manager.\n     */\n    constructor(options) {\n        this._changed = new Signal(this);\n        this._isDisposed = false;\n        this.id = options.plugin.id;\n        this.registry = options.registry;\n        this.registry.pluginChanged.connect(this._onPluginChanged, this);\n    }\n    /**\n     * A signal that emits when the plugin's settings have changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The composite of user settings and extension defaults.\n     */\n    get composite() {\n        return this.plugin.data.composite;\n    }\n    /**\n     * Test whether the plugin settings manager disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    get plugin() {\n        return this.registry.plugins[this.id];\n    }\n    /**\n     * The plugin's schema.\n     */\n    get schema() {\n        return this.plugin.schema;\n    }\n    /**\n     * The plugin settings raw text value.\n     */\n    get raw() {\n        return this.plugin.raw;\n    }\n    /**\n     * The user settings.\n     */\n    get user() {\n        return this.plugin.data.user;\n    }\n    /**\n     * The published version of the NPM package containing these settings.\n     */\n    get version() {\n        return this.plugin.version;\n    }\n    /**\n     * Return the defaults in a commented JSON format.\n     */\n    annotatedDefaults() {\n        return Private.annotatedDefaults(this.schema, this.id);\n    }\n    /**\n     * Calculate the default value of a setting by iterating through the schema.\n     *\n     * @param key - The name of the setting whose default value is calculated.\n     *\n     * @returns A calculated default JSON value for a specific setting.\n     */\n    default(key) {\n        return Private.reifyDefault(this.schema, key);\n    }\n    /**\n     * Dispose of the plugin settings resources.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n    }\n    /**\n     * Get an individual setting.\n     *\n     * @param key - The name of the setting being retrieved.\n     *\n     * @returns The setting value.\n     *\n     * #### Notes\n     * This method returns synchronously because it uses a cached copy of the\n     * plugin settings that is synchronized with the registry.\n     */\n    get(key) {\n        const { composite, user } = this;\n        return {\n            composite: composite[key] !== undefined ? copy(composite[key]) : undefined,\n            user: user[key] !== undefined ? copy(user[key]) : undefined\n        };\n    }\n    /**\n     * Remove a single setting.\n     *\n     * @param key - The name of the setting being removed.\n     *\n     * @returns A promise that resolves when the setting is removed.\n     *\n     * #### Notes\n     * This function is asynchronous because it writes to the setting registry.\n     */\n    remove(key) {\n        return this.registry.remove(this.plugin.id, key);\n    }\n    /**\n     * Save all of the plugin's user settings at once.\n     */\n    save(raw) {\n        return this.registry.upload(this.plugin.id, raw);\n    }\n    /**\n     * Set a single setting.\n     *\n     * @param key - The name of the setting being set.\n     *\n     * @param value - The value of the setting.\n     *\n     * @returns A promise that resolves when the setting has been saved.\n     *\n     * #### Notes\n     * This function is asynchronous because it writes to the setting registry.\n     */\n    set(key, value) {\n        return this.registry.set(this.plugin.id, key, value);\n    }\n    /**\n     * Validates raw settings with comments.\n     *\n     * @param raw - The JSON with comments string being validated.\n     *\n     * @returns A list of errors or `null` if valid.\n     */\n    validate(raw) {\n        const data = { composite: {}, user: {} };\n        const { id, schema } = this.plugin;\n        const validator = this.registry.validator;\n        const version = this.version;\n        return validator.validateData({ data, id, raw, schema, version }, false);\n    }\n    /**\n     * Handle plugin changes in the setting registry.\n     */\n    _onPluginChanged(sender, plugin) {\n        if (plugin === this.plugin.id) {\n            this._changed.emit(undefined);\n        }\n    }\n}\n/**\n * A namespace for `SettingRegistry` statics.\n */\n(function (SettingRegistry) {\n    /**\n     * Reconcile default and user shortcuts and return the composite list.\n     *\n     * @param defaults - The list of default shortcuts.\n     *\n     * @param user - The list of user shortcut overrides and additions.\n     *\n     * @returns A loadable list of shortcuts (omitting disabled and overridden).\n     */\n    function reconcileShortcuts(defaults, user) {\n        const memo = {};\n        // If a user shortcut collides with another user shortcut warn and filter.\n        user = user.filter(shortcut => {\n            const keys = CommandRegistry.normalizeKeys(shortcut).join(RECORD_SEPARATOR);\n            if (!keys) {\n                console.warn('Skipping this shortcut because there are no actionable keys on this platform', shortcut);\n                return false;\n            }\n            if (!(keys in memo)) {\n                memo[keys] = {};\n            }\n            const { selector } = shortcut;\n            if (!(selector in memo[keys])) {\n                memo[keys][selector] = false; // Do not warn if a default shortcut conflicts.\n                return true;\n            }\n            console.warn('Skipping this shortcut because it collides with another shortcut.', shortcut);\n            return false;\n        });\n        // If a default shortcut collides with another default, warn and filter,\n        // unless one of the shortcuts is a disabling shortcut (so look through\n        // disabled shortcuts first). If a shortcut has already been added by the\n        // user preferences, filter it out too (this includes shortcuts that are\n        // disabled by user preferences).\n        defaults = [\n            ...defaults.filter(s => !!s.disabled),\n            ...defaults.filter(s => !s.disabled)\n        ].filter(shortcut => {\n            const keys = CommandRegistry.normalizeKeys(shortcut).join(RECORD_SEPARATOR);\n            if (!keys) {\n                return false;\n            }\n            if (!(keys in memo)) {\n                memo[keys] = {};\n            }\n            const { disabled, selector } = shortcut;\n            if (!(selector in memo[keys])) {\n                // Warn of future conflicts if the default shortcut is not disabled.\n                memo[keys][selector] = !disabled;\n                return true;\n            }\n            // We have a conflict now. Warn the user if we need to do so.\n            if (memo[keys][selector]) {\n                console.warn('Skipping this default shortcut because it collides with another default shortcut.', shortcut);\n            }\n            return false;\n        });\n        // Return all the shortcuts that should be registered\n        return user.concat(defaults).filter(shortcut => !shortcut.disabled);\n    }\n    SettingRegistry.reconcileShortcuts = reconcileShortcuts;\n})(SettingRegistry || (SettingRegistry = {}));\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The default indentation level, uses spaces instead of tabs.\n     */\n    const indent = '    ';\n    /**\n     * Replacement text for schema properties missing a `description` field.\n     */\n    const nondescript = '[missing schema description]';\n    /**\n     * Replacement text for schema properties missing a `title` field.\n     */\n    const untitled = '[missing schema title]';\n    /**\n     * Returns an annotated (JSON with comments) version of a schema's defaults.\n     */\n    function annotatedDefaults(schema, plugin) {\n        const { description, properties, title } = schema;\n        const keys = properties\n            ? Object.keys(properties).sort((a, b) => a.localeCompare(b))\n            : [];\n        const length = Math.max((description || nondescript).length, plugin.length);\n        return [\n            '{',\n            prefix(`${title || untitled}`),\n            prefix(plugin),\n            prefix(description || nondescript),\n            prefix('*'.repeat(length)),\n            '',\n            join(keys.map(key => defaultDocumentedValue(schema, key))),\n            '}'\n        ].join('\\n');\n    }\n    Private.annotatedDefaults = annotatedDefaults;\n    /**\n     * Returns an annotated (JSON with comments) version of a plugin's\n     * setting data.\n     */\n    function annotatedPlugin(plugin, data) {\n        const { description, title } = plugin.schema;\n        const keys = Object.keys(data).sort((a, b) => a.localeCompare(b));\n        const length = Math.max((description || nondescript).length, plugin.id.length);\n        return [\n            '{',\n            prefix(`${title || untitled}`),\n            prefix(plugin.id),\n            prefix(description || nondescript),\n            prefix('*'.repeat(length)),\n            '',\n            join(keys.map(key => documentedValue(plugin.schema, key, data[key]))),\n            '}'\n        ].join('\\n');\n    }\n    Private.annotatedPlugin = annotatedPlugin;\n    /**\n     * Returns the default value-with-documentation-string for a\n     * specific schema property.\n     */\n    function defaultDocumentedValue(schema, key) {\n        const props = (schema.properties && schema.properties[key]) || {};\n        const type = props['type'];\n        const description = props['description'] || nondescript;\n        const title = props['title'] || '';\n        const reified = reifyDefault(schema, key);\n        const spaces = indent.length;\n        const defaults = reified !== undefined\n            ? prefix(`\"${key}\": ${JSON.stringify(reified, null, spaces)}`, indent)\n            : prefix(`\"${key}\": ${type}`);\n        return [prefix(title), prefix(description), defaults]\n            .filter(str => str.length)\n            .join('\\n');\n    }\n    /**\n     * Returns a value-with-documentation-string for a specific schema property.\n     */\n    function documentedValue(schema, key, value) {\n        const props = schema.properties && schema.properties[key];\n        const description = (props && props['description']) || nondescript;\n        const title = (props && props['title']) || untitled;\n        const spaces = indent.length;\n        const attribute = prefix(`\"${key}\": ${JSON.stringify(value, null, spaces)}`, indent);\n        return [prefix(title), prefix(description), attribute].join('\\n');\n    }\n    /**\n     * Returns a joined string with line breaks and commas where appropriate.\n     */\n    function join(body) {\n        return body.reduce((acc, val, idx) => {\n            const rows = val.split('\\n');\n            const last = rows[rows.length - 1];\n            const comment = last.trim().indexOf('//') === 0;\n            const comma = comment || idx === body.length - 1 ? '' : ',';\n            const separator = idx === body.length - 1 ? '' : '\\n\\n';\n            return acc + val + comma + separator;\n        }, '');\n    }\n    /**\n     * Returns a documentation string with a comment prefix added on every line.\n     */\n    function prefix(source, pre = `${indent}// `) {\n        return pre + source.split('\\n').join(`\\n${pre}`);\n    }\n    /**\n     * Create a fully extrapolated default value for a root key in a schema.\n     */\n    function reifyDefault(schema, root) {\n        var _a;\n        // If the property is at the root level, traverse its schema.\n        schema = (root ? (_a = schema.properties) === null || _a === void 0 ? void 0 : _a[root] : schema) || {};\n        // If the property has no default or is a primitive, return.\n        if (!('default' in schema) || schema.type !== 'object') {\n            return schema.default;\n        }\n        // Make a copy of the default value to populate.\n        const result = JSONExt.deepCopy(schema.default);\n        // Iterate through and populate each child property.\n        const props = schema.properties || {};\n        for (const property in props) {\n            result[property] = reifyDefault(props[property]);\n        }\n        return result;\n    }\n    Private.reifyDefault = reifyDefault;\n})(Private || (Private = {}));\n//# sourceMappingURL=settingregistry.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The setting registry token.\n */\nexport const ISettingRegistry = new Token('@jupyterlab/coreutils:ISettingRegistry');\n//# sourceMappingURL=tokens.js.map"],"sourceRoot":""}