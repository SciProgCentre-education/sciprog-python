{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/application/node_modules/@jupyterlab/application/lib/layoutrestorer.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/application/node_modules/@jupyterlab/application/lib/mimerenderers.js"],"names":["ILayoutRestorer","Token","KEY","LayoutRestorer","options","this","_firstDone","_promisesDone","_promises","_restored","PromiseDelegate","_trackers","Set","_widgets","Map","_connector","connector","_first","first","_registry","registry","then","Promise","all","clear","resolve","promise","widget","name","Private","nameProperty","set","disposed","connect","_onWidgetDisposed","blank","fresh","mainArea","leftArea","rightArea","relativeSizes","layout","fetch","data","restored","main","left","right","_rehydrateMainArea","_rehydrateSideArea","error","tracker","warning","console","warn","reject","namespace","has","args","command","when","add","widgetAdded","_","widgetName","widgetUpdated","restore","JSONExt","concat","catch","push","dehydrated","_dehydrateMainArea","_dehydrateSideArea","save","area","serializeMain","deserializeMain","collapsed","currentWidget","current","get","widgets","map","filter","_a","internal","Array","isArray","delete","serializeArea","type","currentIndex","orientation","sizes","children","deserializeArea","names","hydrated","length","child","AttachedProperty","create","owner","dock","IMimeDocumentTracker","createRendermimePlugins","extensions","plugins","WidgetTracker","forEach","mod","default","hasOwnProperty","item","createRendermimePlugin","id","optional","provides","autoStart","activate","app","restorer","path","context","factory","factoryNameProperty","requires","IRenderMimeRegistry","ITranslator","rendermime","translator","undefined","rank","addFactory","rendererFactory","documentWidgetFactoryOptions","docRegistry","fileTypes","ft","icon","Object","assign","LabIcon","addFileType","option","toolbarFactory","w","content","renderer","MimeDocumentFactory","renderTimeout","dataType","modelName","primaryFileType","getFileType","defaultFor","defaultRendered","addWidgetFactory","widgetCreated","sender","pathChanged"],"mappings":"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","file":"77.c446aea065975f519901.js","sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { JSONExt, PromiseDelegate, Token } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\n/**\n * The layout restorer token.\n */\nexport const ILayoutRestorer = new Token('@jupyterlab/application:ILayoutRestorer');\n/**\n * The data connector key for restorer data.\n */\nconst KEY = 'layout-restorer:data';\n/**\n * The default implementation of a layout restorer.\n *\n * #### Notes\n * The lifecycle for state restoration is subtle. The sequence of events is:\n *\n * 1. The layout restorer plugin is instantiated and makes a `fetch` call to\n *    the data connector that stores the layout restoration data. The `fetch`\n *    call returns a promise that resolves in step 6, below.\n *\n * 2. Other plugins that care about state restoration require the layout\n *    restorer as a dependency.\n *\n * 3. As each load-time plugin initializes (which happens before the front-end\n *    application has `started`), it instructs the layout restorer whether\n *    the restorer ought to `restore` its widgets by passing in its widget\n *    tracker.\n *    Alternatively, a plugin that does not require its own widget tracker\n *    (because perhaps it only creates a single widget, like a command palette),\n *    can simply `add` its widget along with a persistent unique name to the\n *    layout restorer so that its layout state can be restored when the lab\n *    application restores.\n *\n * 4. After all the load-time plugins have finished initializing, the front-end\n *    application `started` promise will resolve. This is the `first`\n *    promise that the layout restorer waits for. By this point, all of the\n *    plugins that care about restoration will have instructed the layout\n *    restorer to `restore` their widget trackers.\n *\n * 5. The layout restorer will then instruct each plugin's widget tracker\n *    to restore its state and reinstantiate whichever widgets it wants. The\n *    tracker returns a promise to the layout restorer that resolves when it\n *    has completed restoring the tracked widgets it cares about.\n *\n * 6. As each widget tracker finishes restoring the widget instances it cares\n *    about, it resolves the promise that was returned to the layout restorer\n *    (in step 5). After all of the promises that the restorer is awaiting have\n *    settled, the restorer then resolves the outstanding `fetch` promise\n *    (from step 1) and hands off a layout state object to the application\n *    shell's `restoreLayout` method for restoration.\n *\n * 7. Once the application shell has finished restoring the layout, the\n *    JupyterLab application's `restored` promise is resolved.\n *\n * Of particular note are steps 5 and 6: since data restoration of plugins\n * is accomplished by executing commands, the command that is used to restore\n * the data of each plugin must return a promise that only resolves when the\n * widget has been created and added to the plugin's widget tracker.\n */\nexport class LayoutRestorer {\n    /**\n     * Create a layout restorer.\n     */\n    constructor(options) {\n        this._firstDone = false;\n        this._promisesDone = false;\n        this._promises = [];\n        this._restored = new PromiseDelegate();\n        this._trackers = new Set();\n        this._widgets = new Map();\n        this._connector = options.connector;\n        this._first = options.first;\n        this._registry = options.registry;\n        void this._first\n            .then(() => {\n            this._firstDone = true;\n        })\n            .then(() => Promise.all(this._promises))\n            .then(() => {\n            this._promisesDone = true;\n            // Release the tracker set.\n            this._trackers.clear();\n        })\n            .then(() => {\n            this._restored.resolve(void 0);\n        });\n    }\n    /**\n     * A promise resolved when the layout restorer is ready to receive signals.\n     */\n    get restored() {\n        return this._restored.promise;\n    }\n    /**\n     * Add a widget to be tracked by the layout restorer.\n     */\n    add(widget, name) {\n        Private.nameProperty.set(widget, name);\n        this._widgets.set(name, widget);\n        widget.disposed.connect(this._onWidgetDisposed, this);\n    }\n    /**\n     * Fetch the layout state for the application.\n     *\n     * #### Notes\n     * Fetching the layout relies on all widget restoration to be complete, so\n     * calls to `fetch` are guaranteed to return after restoration is complete.\n     */\n    async fetch() {\n        const blank = {\n            fresh: true,\n            mainArea: null,\n            leftArea: null,\n            rightArea: null,\n            relativeSizes: null\n        };\n        const layout = this._connector.fetch(KEY);\n        try {\n            const [data] = await Promise.all([layout, this.restored]);\n            if (!data) {\n                return blank;\n            }\n            const { main, left, right, relativeSizes } = data;\n            // If any data exists, then this is not a fresh session.\n            const fresh = false;\n            // Rehydrate main area.\n            const mainArea = this._rehydrateMainArea(main);\n            // Rehydrate left area.\n            const leftArea = this._rehydrateSideArea(left);\n            // Rehydrate right area.\n            const rightArea = this._rehydrateSideArea(right);\n            return {\n                fresh,\n                mainArea,\n                leftArea,\n                rightArea,\n                relativeSizes: relativeSizes || null\n            };\n        }\n        catch (error) {\n            return blank;\n        }\n    }\n    /**\n     * Restore the widgets of a particular widget tracker.\n     *\n     * @param tracker - The widget tracker whose widgets will be restored.\n     *\n     * @param options - The restoration options.\n     */\n    restore(tracker, options) {\n        const warning = 'restore() can only be called before `first` has resolved.';\n        if (this._firstDone) {\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const { namespace } = tracker;\n        if (this._trackers.has(namespace)) {\n            const warning = `A tracker namespaced ${namespace} was already restored.`;\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const { args, command, name, when } = options;\n        // Add the tracker to the private trackers collection.\n        this._trackers.add(namespace);\n        // Whenever a new widget is added to the tracker, record its name.\n        tracker.widgetAdded.connect((_, widget) => {\n            const widgetName = name(widget);\n            if (widgetName) {\n                this.add(widget, `${namespace}:${widgetName}`);\n            }\n        }, this);\n        // Whenever a widget is updated, get its new name.\n        tracker.widgetUpdated.connect((_, widget) => {\n            const widgetName = name(widget);\n            if (widgetName) {\n                const name = `${namespace}:${widgetName}`;\n                Private.nameProperty.set(widget, name);\n                this._widgets.set(name, widget);\n            }\n        });\n        const first = this._first;\n        const promise = tracker\n            .restore({\n            args: args || (() => JSONExt.emptyObject),\n            command,\n            connector: this._connector,\n            name,\n            registry: this._registry,\n            when: when ? [first].concat(when) : first\n        })\n            .catch(error => {\n            console.error(error);\n        });\n        this._promises.push(promise);\n        return promise;\n    }\n    /**\n     * Save the layout state for the application.\n     */\n    save(data) {\n        // If there are promises that are unresolved, bail.\n        if (!this._promisesDone) {\n            const warning = 'save() was called prematurely.';\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const dehydrated = {};\n        dehydrated.main = this._dehydrateMainArea(data.mainArea);\n        dehydrated.left = this._dehydrateSideArea(data.leftArea);\n        dehydrated.right = this._dehydrateSideArea(data.rightArea);\n        dehydrated.relativeSizes = data.relativeSizes;\n        return this._connector.save(KEY, dehydrated);\n    }\n    /**\n     * Dehydrate a main area description into a serializable object.\n     */\n    _dehydrateMainArea(area) {\n        if (!area) {\n            return null;\n        }\n        return Private.serializeMain(area);\n    }\n    /**\n     * Reydrate a serialized main area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateMainArea(area) {\n        if (!area) {\n            return null;\n        }\n        return Private.deserializeMain(area, this._widgets);\n    }\n    /**\n     * Dehydrate a side area description into a serializable object.\n     */\n    _dehydrateSideArea(area) {\n        if (!area) {\n            return null;\n        }\n        const dehydrated = { collapsed: area.collapsed };\n        if (area.currentWidget) {\n            const current = Private.nameProperty.get(area.currentWidget);\n            if (current) {\n                dehydrated.current = current;\n            }\n        }\n        if (area.widgets) {\n            dehydrated.widgets = area.widgets\n                .map(widget => Private.nameProperty.get(widget))\n                .filter(name => !!name);\n        }\n        return dehydrated;\n    }\n    /**\n     * Reydrate a serialized side area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateSideArea(area) {\n        var _a;\n        if (!area) {\n            return { collapsed: true, currentWidget: null, widgets: null };\n        }\n        const internal = this._widgets;\n        const collapsed = (_a = area.collapsed) !== null && _a !== void 0 ? _a : false;\n        const currentWidget = area.current && internal.has(`${area.current}`)\n            ? internal.get(`${area.current}`)\n            : null;\n        const widgets = !Array.isArray(area.widgets)\n            ? null\n            : area.widgets\n                .map(name => internal.has(`${name}`) ? internal.get(`${name}`) : null)\n                .filter(widget => !!widget);\n        return {\n            collapsed,\n            currentWidget: currentWidget,\n            widgets: widgets\n        };\n    }\n    /**\n     * Handle a widget disposal.\n     */\n    _onWidgetDisposed(widget) {\n        const name = Private.nameProperty.get(widget);\n        this._widgets.delete(name);\n    }\n}\n/*\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for a widget's ID in the serialized restore data.\n     */\n    Private.nameProperty = new AttachedProperty({\n        name: 'name',\n        create: owner => ''\n    });\n    /**\n     * Serialize individual areas within the main area.\n     */\n    function serializeArea(area) {\n        if (!area || !area.type) {\n            return null;\n        }\n        if (area.type === 'tab-area') {\n            return {\n                type: 'tab-area',\n                currentIndex: area.currentIndex,\n                widgets: area.widgets\n                    .map(widget => Private.nameProperty.get(widget))\n                    .filter(name => !!name)\n            };\n        }\n        return {\n            type: 'split-area',\n            orientation: area.orientation,\n            sizes: area.sizes,\n            children: area.children\n                .map(serializeArea)\n                .filter(area => !!area)\n        };\n    }\n    /**\n     * Return a dehydrated, serializable version of the main dock panel.\n     */\n    function serializeMain(area) {\n        const dehydrated = {\n            dock: (area && area.dock && serializeArea(area.dock.main)) || null\n        };\n        if (area) {\n            if (area.currentWidget) {\n                const current = Private.nameProperty.get(area.currentWidget);\n                if (current) {\n                    dehydrated.current = current;\n                }\n            }\n        }\n        return dehydrated;\n    }\n    Private.serializeMain = serializeMain;\n    /**\n     * Deserialize individual areas within the main area.\n     *\n     * #### Notes\n     * Because this data comes from a potentially unreliable foreign source, it is\n     * typed as a `JSONObject`; but the actual expected type is:\n     * `ITabArea | ISplitArea`.\n     *\n     * For fault tolerance, types are manually checked in deserialization.\n     */\n    function deserializeArea(area, names) {\n        if (!area) {\n            return null;\n        }\n        // Because this data is saved to a foreign data source, its type safety is\n        // not guaranteed when it is retrieved, so exhaustive checks are necessary.\n        const type = area.type || 'unknown';\n        if (type === 'unknown' || (type !== 'tab-area' && type !== 'split-area')) {\n            console.warn(`Attempted to deserialize unknown type: ${type}`);\n            return null;\n        }\n        if (type === 'tab-area') {\n            const { currentIndex, widgets } = area;\n            const hydrated = {\n                type: 'tab-area',\n                currentIndex: currentIndex || 0,\n                widgets: (widgets &&\n                    widgets\n                        .map(widget => names.get(widget))\n                        .filter(widget => !!widget)) ||\n                    []\n            };\n            // Make sure the current index is within bounds.\n            if (hydrated.currentIndex > hydrated.widgets.length - 1) {\n                hydrated.currentIndex = 0;\n            }\n            return hydrated;\n        }\n        const { orientation, sizes, children } = area;\n        const hydrated = {\n            type: 'split-area',\n            orientation: orientation,\n            sizes: sizes || [],\n            children: (children &&\n                children\n                    .map(child => deserializeArea(child, names))\n                    .filter(widget => !!widget)) ||\n                []\n        };\n        return hydrated;\n    }\n    /**\n     * Return the hydrated version of the main dock panel, ready to restore.\n     *\n     * #### Notes\n     * Because this data comes from a potentially unreliable foreign source, it is\n     * typed as a `JSONObject`; but the actual expected type is: `IMainArea`.\n     *\n     * For fault tolerance, types are manually checked in deserialization.\n     */\n    function deserializeMain(area, names) {\n        if (!area) {\n            return null;\n        }\n        const name = area.current || null;\n        const dock = area.dock || null;\n        return {\n            currentWidget: (name && names.has(name) && names.get(name)) || null,\n            dock: dock ? { main: deserializeArea(dock, names) } : null\n        };\n    }\n    Private.deserializeMain = deserializeMain;\n})(Private || (Private = {}));\n//# sourceMappingURL=layoutrestorer.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { WidgetTracker } from '@jupyterlab/apputils';\nimport { MimeDocumentFactory } from '@jupyterlab/docregistry';\nimport { IRenderMimeRegistry } from '@jupyterlab/rendermime';\nimport { LabIcon } from '@jupyterlab/ui-components';\nimport { Token } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\nimport { ILayoutRestorer } from './layoutrestorer';\nimport { ITranslator } from '@jupyterlab/translation';\n/**\n * The mime document tracker token.\n */\nexport const IMimeDocumentTracker = new Token('@jupyterlab/application:IMimeDocumentTracker');\n/**\n * Create rendermime plugins for rendermime extension modules.\n */\nexport function createRendermimePlugins(extensions) {\n    const plugins = [];\n    const namespace = 'application-mimedocuments';\n    const tracker = new WidgetTracker({ namespace });\n    extensions.forEach(mod => {\n        let data = mod.default;\n        // Handle CommonJS exports.\n        if (!mod.hasOwnProperty('__esModule')) {\n            data = mod;\n        }\n        if (!Array.isArray(data)) {\n            data = [data];\n        }\n        data.forEach(item => {\n            plugins.push(createRendermimePlugin(tracker, item));\n        });\n    });\n    // Also add a meta-plugin handling state restoration\n    // and exposing the mime document widget tracker.\n    plugins.push({\n        id: '@jupyterlab/application:mimedocument',\n        optional: [ILayoutRestorer],\n        provides: IMimeDocumentTracker,\n        autoStart: true,\n        activate: (app, restorer) => {\n            if (restorer) {\n                void restorer.restore(tracker, {\n                    command: 'docmanager:open',\n                    args: widget => ({\n                        path: widget.context.path,\n                        factory: Private.factoryNameProperty.get(widget)\n                    }),\n                    name: widget => `${widget.context.path}:${Private.factoryNameProperty.get(widget)}`\n                });\n            }\n            return tracker;\n        }\n    });\n    return plugins;\n}\n/**\n * Create rendermime plugins for rendermime extension modules.\n */\nexport function createRendermimePlugin(tracker, item) {\n    return {\n        id: item.id,\n        requires: [IRenderMimeRegistry, ITranslator],\n        autoStart: true,\n        activate: (app, rendermime, translator) => {\n            // Add the mime renderer.\n            if (item.rank !== undefined) {\n                rendermime.addFactory(item.rendererFactory, item.rank);\n            }\n            else {\n                rendermime.addFactory(item.rendererFactory);\n            }\n            // Handle the widget factory.\n            if (!item.documentWidgetFactoryOptions) {\n                return;\n            }\n            const registry = app.docRegistry;\n            let options = [];\n            if (Array.isArray(item.documentWidgetFactoryOptions)) {\n                options = item.documentWidgetFactoryOptions;\n            }\n            else {\n                options = [\n                    item.documentWidgetFactoryOptions\n                ];\n            }\n            if (item.fileTypes) {\n                item.fileTypes.forEach(ft => {\n                    if (ft.icon) {\n                        // upconvert the contents of the icon field to a proper LabIcon\n                        ft = Object.assign(Object.assign({}, ft), { icon: LabIcon.resolve({ icon: ft.icon }) });\n                    }\n                    app.docRegistry.addFileType(ft);\n                });\n            }\n            options.forEach(option => {\n                const toolbarFactory = option.toolbarFactory\n                    ? (w) => option.toolbarFactory(w.content.renderer)\n                    : undefined;\n                const factory = new MimeDocumentFactory({\n                    renderTimeout: item.renderTimeout,\n                    dataType: item.dataType,\n                    rendermime,\n                    modelName: option.modelName,\n                    name: option.name,\n                    primaryFileType: registry.getFileType(option.primaryFileType),\n                    fileTypes: option.fileTypes,\n                    defaultFor: option.defaultFor,\n                    defaultRendered: option.defaultRendered,\n                    toolbarFactory,\n                    translator,\n                    factory: item.rendererFactory\n                });\n                registry.addWidgetFactory(factory);\n                factory.widgetCreated.connect((sender, widget) => {\n                    Private.factoryNameProperty.set(widget, factory.name);\n                    // Notify the widget tracker if restore data needs to update.\n                    widget.context.pathChanged.connect(() => {\n                        void tracker.save(widget);\n                    });\n                    void tracker.add(widget);\n                });\n            });\n        }\n    };\n}\n/**\n * Private namespace for the module.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for keeping the factory name\n     * that was used to create a mimedocument.\n     */\n    Private.factoryNameProperty = new AttachedProperty({\n        name: 'factoryName',\n        create: () => undefined\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=mimerenderers.js.map"],"sourceRoot":""}