{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/tooltip/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/tooltip/lib/widget.js"],"names":["ITooltipManager","Token","BODY_CLASS","USE_CAPTURE","Tooltip","Widget","options","super","this","_content","layout","PanelLayout","model","MimeModel","data","bundle","anchor","addClass","hide","_editor","editor","_rendermime","rendermime","mimeType","preferredMimeType","createRenderer","renderModel","addWidget","dispose","event","isHidden","isDisposed","node","target","type","contains","activate","_evtScroll","msg","tabIndex","focus","document","body","classList","add","addEventListener","update","remove","removeEventListener","show","_setGeometry","onUpdateRequest","cursor","getCursorPosition","end","getOffsetAt","line","getLine","tokens","substring","split","last","length","start","position","getPositionAt","getCoordinateForPosition","style","window","getComputedStyle","paddingLeft","parseInt","HoverBox","host","maxHeight","minHeight","offset","horizontal","privilege"],"mappings":"4LAOO,MAAMA,EAAkB,I,SAAIC,OAAM,uC,kCCEzC,MAQMC,EAAa,iBAYbC,GAAc,EAIb,MAAMC,UAAgB,EAAAC,OAIzB,YAAYC,GACRC,QACAC,KAAKC,SAAW,KAChB,MAAMC,EAAUF,KAAKE,OAAS,IAAI,EAAAC,YAC5BC,EAAQ,IAAI,EAAAC,UAAU,CAAEC,KAAMR,EAAQS,SAC5CP,KAAKQ,OAASV,EAAQU,OACtBR,KAAKS,SAlCS,cAmCdT,KAAKU,OACLV,KAAKW,QAAUb,EAAQc,OACvBZ,KAAKa,YAAcf,EAAQgB,WAC3B,MAAMC,EAAWf,KAAKa,YAAYG,kBAAkBlB,EAAQS,OAAQ,OAC/DQ,IAGLf,KAAKC,SAAWD,KAAKa,YAAYI,eAAeF,GAC3Cf,KAAKC,SAASiB,YAAYd,GAC/BJ,KAAKC,SAASQ,SAxCA,sBAyCdP,EAAOiB,UAAUnB,KAAKC,WAK1B,UACQD,KAAKC,WACLD,KAAKC,SAASmB,UACdpB,KAAKC,SAAW,MAEpBF,MAAMqB,UAYV,YAAYC,GACR,GAAIrB,KAAKsB,UAAYtB,KAAKuB,WACtB,OAEJ,MAAM,KAAEC,GAASxB,KACXyB,EAASJ,EAAMI,OACrB,OAAQJ,EAAMK,MACV,IAAK,UACD,GAAIF,EAAKG,SAASF,GACd,OAEJzB,KAAKoB,UACL,MACJ,IAAK,YACD,GAAII,EAAKG,SAASF,GAEd,YADAzB,KAAK4B,WAGT5B,KAAKoB,UACL,MACJ,IAAK,SACDpB,KAAK6B,WAAWR,IAS5B,kBAAkBS,GACd9B,KAAKwB,KAAKO,SAAW,EACrB/B,KAAKwB,KAAKQ,QAKd,cAAcF,GACVG,SAASC,KAAKC,UAAUC,IAAI1C,GAC5BuC,SAASI,iBAAiB,UAAWrC,KAAML,GAC3CsC,SAASI,iBAAiB,YAAarC,KAAML,GAC7CK,KAAKQ,OAAOgB,KAAKa,iBAAiB,SAAUrC,KAAML,GAClDK,KAAKsC,SAKT,eAAeR,GACXG,SAASC,KAAKC,UAAUI,OAAO7C,GAC/BuC,SAASO,oBAAoB,UAAWxC,KAAML,GAC9CsC,SAASO,oBAAoB,YAAaxC,KAAML,GAChDK,KAAKQ,OAAOgB,KAAKgB,oBAAoB,SAAUxC,KAAML,GAKzD,gBAAgBmC,GACR9B,KAAKsB,UACLtB,KAAKyC,OAETzC,KAAK0C,eACL3C,MAAM4C,gBAAgBb,GAK1B,WAAWT,GAIHrB,KAAKwB,KAAKG,SAASN,EAAMI,SAG7BzB,KAAKsC,SAKT,eAEI,MAAM1B,EAASZ,KAAKW,QACdiC,EAAShC,EAAOiC,oBAChBC,EAAMlC,EAAOmC,YAAYH,GACzBI,EAAOpC,EAAOqC,QAAQL,EAAOI,MACnC,IAAKA,EACD,OAEJ,MAAME,EAASF,EAAKG,UAAU,EAAGL,GAAKM,MAAM,OACtCC,EAAOH,EAAOA,EAAOI,OAAS,GAC9BC,EAAQF,EAAOP,EAAMO,EAAKC,OAASR,EACnCU,EAAW5C,EAAO6C,cAAcF,GACtC,IAAKC,EACD,OAEJ,MAAMhD,EAASI,EAAO8C,yBAAyBF,GACzCG,EAAQC,OAAOC,iBAAiB7D,KAAKwB,MACrCsC,EAAcC,SAASJ,EAAMG,YAAa,KAAO,EAEvD,EAAAE,SAAA,YAAqB,CACjBxD,SACAyD,KAAMrD,EAAOqD,KACbC,UAxJO,IAyJPC,UA7JO,GA8JP3C,KAAMxB,KAAKwB,KACX4C,OAAQ,CAAEC,YAAa,EAAIP,GAC3BQ,UAAW,QACXX,MAAOA","file":"8961.b23a57230057b3da8ba3.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The tooltip manager token.\n */\nexport const ITooltipManager = new Token('@jupyterlab/tooltip:ITooltipManager');\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PanelLayout } from '@lumino/widgets';\nimport { Widget } from '@lumino/widgets';\nimport { HoverBox } from '@jupyterlab/apputils';\nimport { MimeModel } from '@jupyterlab/rendermime';\n/**\n * The class name added to each tooltip.\n */\nconst TOOLTIP_CLASS = 'jp-Tooltip';\n/**\n * The class name added to the tooltip content.\n */\nconst CONTENT_CLASS = 'jp-Tooltip-content';\n/**\n * The class added to the body when a tooltip exists on the page.\n */\nconst BODY_CLASS = 'jp-mod-tooltip';\n/**\n * The minimum height of a tooltip widget.\n */\nconst MIN_HEIGHT = 20;\n/**\n * The maximum height of a tooltip widget.\n */\nconst MAX_HEIGHT = 250;\n/**\n * A flag to indicate that event handlers are caught in the capture phase.\n */\nconst USE_CAPTURE = true;\n/**\n * A tooltip widget.\n */\nexport class Tooltip extends Widget {\n    /**\n     * Instantiate a tooltip.\n     */\n    constructor(options) {\n        super();\n        this._content = null;\n        const layout = (this.layout = new PanelLayout());\n        const model = new MimeModel({ data: options.bundle });\n        this.anchor = options.anchor;\n        this.addClass(TOOLTIP_CLASS);\n        this.hide();\n        this._editor = options.editor;\n        this._rendermime = options.rendermime;\n        const mimeType = this._rendermime.preferredMimeType(options.bundle, 'any');\n        if (!mimeType) {\n            return;\n        }\n        this._content = this._rendermime.createRenderer(mimeType);\n        void this._content.renderModel(model);\n        this._content.addClass(CONTENT_CLASS);\n        layout.addWidget(this._content);\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this._content) {\n            this._content.dispose();\n            this._content = null;\n        }\n        super.dispose();\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the dock panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        if (this.isHidden || this.isDisposed) {\n            return;\n        }\n        const { node } = this;\n        const target = event.target;\n        switch (event.type) {\n            case 'keydown':\n                if (node.contains(target)) {\n                    return;\n                }\n                this.dispose();\n                break;\n            case 'mousedown':\n                if (node.contains(target)) {\n                    this.activate();\n                    return;\n                }\n                this.dispose();\n                break;\n            case 'scroll':\n                this._evtScroll(event);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        this.node.tabIndex = 0;\n        this.node.focus();\n    }\n    /**\n     * Handle `'after-attach'` messages.\n     */\n    onAfterAttach(msg) {\n        document.body.classList.add(BODY_CLASS);\n        document.addEventListener('keydown', this, USE_CAPTURE);\n        document.addEventListener('mousedown', this, USE_CAPTURE);\n        this.anchor.node.addEventListener('scroll', this, USE_CAPTURE);\n        this.update();\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        document.body.classList.remove(BODY_CLASS);\n        document.removeEventListener('keydown', this, USE_CAPTURE);\n        document.removeEventListener('mousedown', this, USE_CAPTURE);\n        this.anchor.node.removeEventListener('scroll', this, USE_CAPTURE);\n    }\n    /**\n     * Handle `'update-request'` messages.\n     */\n    onUpdateRequest(msg) {\n        if (this.isHidden) {\n            this.show();\n        }\n        this._setGeometry();\n        super.onUpdateRequest(msg);\n    }\n    /**\n     * Handle scroll events for the widget\n     */\n    _evtScroll(event) {\n        // All scrolls except scrolls in the actual hover box node may cause the\n        // referent editor that anchors the node to move, so the only scroll events\n        // that can safely be ignored are ones that happen inside the hovering node.\n        if (this.node.contains(event.target)) {\n            return;\n        }\n        this.update();\n    }\n    /**\n     * Set the geometry of the tooltip widget.\n     */\n    _setGeometry() {\n        // Find the start of the current token for hover box placement.\n        const editor = this._editor;\n        const cursor = editor.getCursorPosition();\n        const end = editor.getOffsetAt(cursor);\n        const line = editor.getLine(cursor.line);\n        if (!line) {\n            return;\n        }\n        const tokens = line.substring(0, end).split(/\\W+/);\n        const last = tokens[tokens.length - 1];\n        const start = last ? end - last.length : end;\n        const position = editor.getPositionAt(start);\n        if (!position) {\n            return;\n        }\n        const anchor = editor.getCoordinateForPosition(position);\n        const style = window.getComputedStyle(this.node);\n        const paddingLeft = parseInt(style.paddingLeft, 10) || 0;\n        // Calculate the geometry of the tooltip.\n        HoverBox.setGeometry({\n            anchor,\n            host: editor.host,\n            maxHeight: MAX_HEIGHT,\n            minHeight: MIN_HEIGHT,\n            node: this.node,\n            offset: { horizontal: -1 * paddingLeft },\n            privilege: 'below',\n            style: style\n        });\n    }\n}\n//# sourceMappingURL=widget.js.map"],"sourceRoot":""}